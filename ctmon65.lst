AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- ctmon65.asm ---------------------------------

2422 lines read, no errors in pass 1.
                        ;*****************************************************
                        ; CTMON65
                        ;
                        ; This is the monitor for the Corsham Techologies, LLC
                        ; SS-50 65C02 board.  It's a fairly generic monitor th
                        ; can be ported to other 6502 based systems.
                        ;
                        ; Written mostly while on a family vacation in 2018, b
                        ; ideas and code were taken from other Corsham Tech
                        ; projects and various web pages (credit given in the
                        ; code).
                        ;
                        ; Bob Applegate
                        ; bob@corshamtech.com
                        ; www.corshamtech.com
                        ;*****************************************************
                        
                        ;=====================================================
                        ;-----------------------------------------------------
                        
                        		include	"config.inc"
                        ;*****************************************************
                        ; FILE: config.inc
                        ;
                        ; General configuration file
                        ;*****************************************************
                        ;
                        ; Current version and revision
                        ;
                        ;VERSION		equ	0
                        ;REVISION	equ	1
                        ;
0000 =                  FALSE		equ	0
0001 =                  TRUE		equ	!FALSE
                        ;
                        ; SS-50 bus constants
                        ;
e000 =                  IO_BASE		equ	$e000
0010 =                  IO_SIZE		equ	16
                        ;
                        ; Memory usage
                        ;
00f0 =                  ZERO_PAGE_START	equ	$00f0
f000 =                  ROM_START	equ	$f000
df00 =                  RAM_START	equ	$df00
                        ;
                        ; If enabled, turn on buffered input code.
                        ;
0000 =                  BUFFERED_INPUT	equ	FALSE
                        ;
0005 =                  MAX_ARGC	equ	5
                        ;
                        ; If enabled, the debugger will display the flag regis
                        ; in ASCII.  Nice, but takes more code.
                        ;
0001 =                  FULL_STATUS	equ	TRUE
                        ;
                        ; Enable EXTENDED_CMDS to allow linking external comma
                        ; to the command handler.
                        ;
0000 =                  EXTENDED_CMDS	equ	FALSE
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ; Define to enable SD related functions
                        ;
0001 =                  SD_ENABLED	equ	TRUE
                        ;
                        ; Size of the keyboard buffer
                        ;
0084 =                  BUFFER_SIZE	equ	132
                        
                        
                        ;
                        ; Version and revision
                        ;
0000 =                  VERSION		equ	0
0002 =                  REVISION	equ	2
                        ;
                        ;-----------------------------------------------------
                        ; ASCII constants
                        ;
0007 =                  BELL		equ	$07
0008 =                  BS		equ	$08
000a =                  LF		equ	$0a
000d =                  CR		equ	$0d
                        ;
                        ; Max number of bytes per line for hex dump
                        ;
0010 =                  BYTESLINE	equ	16
                        ;
                        ; These are various buffer sizes
                        ;
000c =                  FILENAME_SIZE	equ	12
                        ;
                        ; Intel HEX record types
                        ;
0000 =                  DATA_RECORD	equ	$00
0001 =                  EOF_RECORD	equ	$01
                        ;
                        ; Zero-page data
                        ;
                        ;		zpage
                        		bss
00f0 =                  		org	ZERO_PAGE_START
00f0 =                  sptr		ds	2
00f2 =                  INL		ds	1
00f3 =                  INH		ds	1
00f4 =                  putsp		ds	2
                        ;
                        ; Non zero-page data
                        ;
                        		bss
df00 =                  		org	RAM_START
                        ;
                        ; The use of memory starting from here will remain
                        ; constant through different versions of CTMON65.
                        ;
df00 =                  IRQvec		ds	2
df02 =                  NMIvec		ds	2
                        ;
                        ; Before a L(oad) command, these are set to $FF.
                        ; After loading, if they are different, jump to
                        ; that address.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- ctmon65.asm ---------------------------------

df04 =                  AutoRun		ds	2
                        ;
                        ; Pointer to the subroutine that gets the next input
                        ; character.  Used for doing disk/console input.
                        ;
df06 =                  inputVector	ds	2
                        ;
                        ; Same thing for output.
                        ;
df08 =                  outputVector	ds	2
                        ;
                        ; Buffer for GETLINE
                        ;
df0a =                  buffer		ds	BUFFER_SIZE
                        ;
                        ; Anything from here can be moved between versions.
                        ;
df8e =                  SaveA		ds	1
df8f =                  SaveX		ds	1
df90 =                  SaveY		ds	1
df91 =                  SavePC		ds	2
df93 =                  SaveC		ds	1
df94 =                  SaveSP		ds	1
df95 =                  SAL		ds	1
df96 =                  SAH		ds	1
df97 =                  EAL		ds	1
df98 =                  EAH		ds	1
df99 =                  tempA		ds	1
df9a =                  filename	ds	FILENAME_SIZE+1
dfa7 =                  diskBufOffset	ds	1
dfa8 =                  diskBufLength	ds	1
dfa9 =                  CHKL		ds	1
dfaa =                  ID		ds	1
dfab =                  Temp16L		ds	1
dfac =                  Temp16H		ds	1
                        ;
                        ; This weird bit of DBs is to allow for the fact that
                        ; I'm putting a 4K monitor into the top half of an
                        ; 8K EEPROM.  This forces the actual code to the top
                        ; 4K section.
                        ;
                        		code
e000 =                  		org	ROM_START-$1000
e000 : 54686973207370.. 		db	"This space for rent.",CR,LF
e016 : 41637475616c6c.. 		db	"Actually, this just forces the "
e035 : 62696e61727920.. 		db	"binary file to be 8K long."
                        ;
f000 =                  		org	ROM_START
                        ;
                        ;=====================================================
                        ; Jump table to common functions.  The entries in this
                        ; table are used by external programs, so nothing can 
                        ; moved or removed from this table.  New entries alway
                        ; go at the end.  Many of these are internal functions
                        ; and I figured they might be handy for others.
                        ;
f000 : 4c45f0           COLDvec		jmp	RESET
f003 : 4cb4f0           WARMvec		jmp	WARM
                        ;
                        ; These are the major and minor revision numbers so th
                        ; code can check to see which CTMON65 version is runni
                        ;
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- ctmon65.asm ---------------------------------

f006 : 00               CTMON65ver	db	VERSION
f007 : 02               CTMON65rev	db	REVISION
f008 : 00               		db	0
                        ;
                        ; Console related functions
                        ;
f009 : 4c0afb           CINvec		jmp	cin
f00c : 4cfdfa           COUTvec		jmp	cout
f00f : 4c15fb           CSTATvec	jmp	cstatus
f012 : 4c60fa           PUTSILvec	jmp	putsil
f015 : 4c9efa           GETLINEvec	jmp	getline
f018 : 4cd6fa           CRLFvec		jmp	crlf
f01b : 4cb9fa           OUTHEXvec	jmp	HexA
                        ;
                        ; Low-level functions to access the SD card system
                        ;
                        	if	SD_ENABLED
f01e : 4c1bfb           XPARINITvev	jmp	xParInit
f021 : 4c2afb           XPARSETWRITEvec	jmp	xParSetWrite
f024 : 4c3ffb           XPARSETREADvec	jmp	xParSetRead
f027 : 4c54fb           XPARWRITEvec	jmp	xParWriteByte
f02a : 4c7ffb           XPARREADvec	jmp	xParReadByte
                        ;
                        ; Higher level SD card functions
                        ;
f02d : 4ca3fb           DISKPINGvec	jmp	DiskPing
f030 : 4cb6fb           DISKDIRvec	jmp	DiskDir
f033 : 4cc0fb           DISKDIRNEXTVEC	jmp	DiskDirNext
f036 : 4cf1fb           DISKOPENREADvec	jmp	DiskOpenRead
f039 : 4c22fc           DISKOPENWRITvec	jmp	DiskOpenWrite
f03c : 4c27fc           DISKREADvec	jmp	DiskRead
f03f : 4c59fc           DISKWRITEvec	jmp	DiskWrite
f042 : 4c90fc           DISKCLOSEvec	jmp	DiskClose
                        	endif	;SD_ENABLED
                        ;
                        ;-----------------------------------------------------
                        ; Cold start entry point
                        ;
f045 : a2ff             RESET		ldx	#$ff
f047 : 9a               		txs
f048 : 20f1fa           		jsr	cinit
f04b : 201bfb           		jsr	xParInit
                        ;
                        ; Reset the NMI and IRQ vectors
                        ;
f04e : a99b             		lda	#DefaultNMI&$ff
f050 : 8d02df           		sta	NMIvec
f053 : a9fc             		lda	#DefaultNMI>>8
f055 : 8d03df           		sta	NMIvec+1
                        ;
f058 : a99b             		lda	#DefaultIRQ&$ff
f05a : 8d00df           		sta	IRQvec
f05d : a9fc             		lda	#DefaultIRQ>>8
f05f : 8d01df           		sta	IRQvec+1
                        ;
                        ; Print start-up message
                        ;
f062 : 2060fa           		jsr	putsil
f065 : 0d0a0a0a0a       		db	CR,LF,LF,LF,LF
f06a : 43544d4f4e3635.. 		db	"CTMON65 rev "
f076 : 302e             		db	VERSION+'0','.'
f078 : 32               		db	REVISION+'0'
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- ctmon65.asm ---------------------------------

f079 : 0d0a             		db	CR,LF
f07b : 30392f32302f32.. 		db	"09/20/2018 by Bob Applegate K2UT"
f09b : 2c20626f624063.. 		db	", bob@corshamtech.com"
f0b0 : 0d0a0a00         		db	CR,LF,LF,0
                        ;
                        ;-----------------------------------------------------
                        ; Warm start entry point.  This is the best place to j
                        ; in the code after a user program has ended.  Go thro
                        ; the vector, of course!
                        ;
f0b4 : a2ff             WARM		ldx	#$ff
f0b6 : 9a               		txs
                        ;
                        ; Prompt the user and get a line of text
                        ;
f0b7 : 2083f9           prompt		jsr	setOutputConsole
f0ba : 209ef9           		jsr	setInputConsole
f0bd : 2060fa           		jsr	putsil
f0c0 : 0d0a             		db	CR,LF
f0c2 : 43544d4f4e3635.. 		db	"CTMON65> "
f0cb : 00               		db	0
f0cc : 200afb           prompt2		jsr	cin
f0cf : c90d             		cmp	#CR
f0d1 : f0e4             		beq	prompt
f0d3 : c90a             		cmp	#LF
f0d5 : f0f5             		beq	prompt2	;don't prompt
f0d7 : 8d99df           		sta	tempA
                        ;
                        ; Now cycle through the list of commands looking for
                        ; what the user just pressed.
                        ;
f0da : a9f3             		lda	#commandTable&$ff
f0dc : 85f0             		sta	sptr
f0de : a9f0             		lda	#commandTable/256
f0e0 : 85f1             		sta	sptr+1
f0e2 : 2074f2           		jsr	searchCmd	;try to find it
                        ;
                        ; Hmmm... wasn't one of the built in commands, so
                        ; see if it's an extended command.
                        ;
                        	if	EXTENDED_CMDS
                        		lda	ExtensionAddr
                        		sta	sptr
                        		lda	ExtensionAddr+1
                        		sta	sptr+1
                        		jsr	searchCmd	;try to find it
                        	endif
                        ;
                        ; If that returns, then the command was not found.
                        ; Print that it's unknown.
                        ;
f0e5 : 2060fa           		jsr	putsil
f0e8 : 202d204875683f00 		db	" - Huh?",0
f0f0 : 4cb7f0           cmdFound	jmp	prompt
                        ;
                        ;=====================================================
                        ; Vector table of commands.  Each entry consists of a
                        ; single ASCII character (the command), a pointer to
                        ; the function which handles the command, and a pointe
                        ; to a string that describes the command.
                        ;
f0f3 : 3f               commandTable	db	'?'
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- ctmon65.asm ---------------------------------

f0f4 : 96f7             		dw	showHelp
f0f6 : 2bf1             		dw	quesDesc
                        ;
f0f8 : 43               		db	'C'
f0f9 : fff6             		dw	doContinue
f0fb : 48f1             		dw	cDesc
                        ;
f0fd : 44               		db	'D'
f0fe : 29f9             		dw	doDiskDir
f100 : 69f1             		dw	dDesc
                        ;
f102 : 45               		db	'E'	;edit memory
f103 : 41f3             		dw	editMemory
f105 : 86f1             		dw	eDesc
                        ;
f107 : 48               		db	'H'	;hex dump
f108 : b2f2             		dw	hexDump
f10a : a0f1             		dw	hDesc
                        ;
f10c : 4a               		db	'J'	;jump to address
f10d : 98f2             		dw	jumpAddress
f10f : bef1             		dw	jDesc
                        ;
f111 : 4c               		db	'L'	;load Intel HEX file
f112 : a2f3             		dw	loadHex
f114 : dcf1             		dw	lDesc
                        ;
f116 : 4d               		db	'M'	;perform memory test
f117 : e9f7             		dw	memTest
f119 : f8f1             		dw	mDesc
                        ;
f11b : 50               		db	'P'	;ping remote disk
f11c : 09f9             		dw	pingDisk
f11e : 12f2             		dw	pDesc
                        ;
f120 : 53               		db	'S'	;save memory as hex file
f121 : e8f4             		dw	saveHex
f123 : 35f2             		dw	sDesc
                        ;
f125 : 54               		db	'T'	;type a file on SD
f126 : f7f9             		dw	typeFile
f128 : 57f2             		dw	tDesc
                        ;
f12a : 00               		db	0	;marks end of table
                        ;
                        ;=====================================================
                        ; Descriptions for each command in the command table.
                        ; This wastes a lot of space... I'm open for any
                        ; suggestions to keep the commands clear but reducing
                        ; the amount of space this table consumes.
                        ;
f12b : 3f202e2e2e2e2e.. quesDesc	db	"? ........... Show this help",0
f148 : 43202e2e2e2e2e.. cDesc		db	"C ........... Continue execution",0
f169 : 44202e2e2e2e2e.. dDesc		db	"D ........... Disk directory",0
f186 : 45207878787820.. eDesc		db	"E xxxx ...... Edit memory",0
f1a0 : 48207878787820.. hDesc		db	"H xxxx xxxx . Hex dump memory",0
f1be : 4a207878787820.. jDesc		db	"J xxxx ...... Jump to address",0
f1dc : 4c202e2e2e2e2e.. lDesc		db	"L ........... Load HEX file",0
f1f8 : 4d207878787820.. mDesc		db	"M xxxx xxxx . Memory test",0
f212 : 50202e2e2e2e2e.. pDesc		db	"P ........... Ping disk controller",0
f235 : 53207878787820.. sDesc		db	"S xxxx xxxx . Save memory to file",0
f257 : 54202e2e2e2e2e.. tDesc		db	"T ........... Type disk file",0
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; This subroutine will search for a command in a table
                        ; and call the appropriate handler.  See the command
                        ; table near the start of the code for what the format
                        ; is.  If a match is found, pop off the return address
                        ; from the stack and jump to the code.  Else, return.
                        ;
f274 : a000             searchCmd	ldy	#0
f276 : b1f0             cmdLoop		lda	(sptr),y
f278 : f01d             		beq	cmdNotFound
f27a : cd99df           		cmp	tempA	;compare to user's input
f27d : f007             		beq	cmdMatch
f27f : c8               		iny		;start of function ptr
f280 : c8               		iny
f281 : c8               		iny		;start of help
f282 : c8               		iny
f283 : c8               		iny		;move to next command
f284 : d0f0             		bne	cmdLoop
                        ;
                        ; It's found!  Load up the address of the code to call
                        ; pop the return address off the stack and jump to the
                        ; handler.
                        ;
f286 : c8               cmdMatch	iny
f287 : b1f0             		lda	(sptr),y	;handler LSB
f289 : 48               		pha
f28a : c8               		iny
f28b : b1f0             		lda	(sptr),y	;handler MSB
f28d : 85f1             		sta	sptr+1
f28f : 68               		pla
f290 : 85f0             		sta	sptr
f292 : 68               		pla		;pop return address
f293 : 68               		pla
f294 : 6cf000           		jmp	(sptr)
                        ;
                        ; Not found, so just return.
                        ;
f297 : 60               cmdNotFound	rts
                        ;
                        ;=====================================================
                        ; Handles the command to prompt for an address and the
                        ; jump to it.
                        ;
f298 : 2060fa           jumpAddress	jsr	putsil
f29b : 4a756d7020746f.. 		db	"Jump to ",0
f2a4 : 2053f7           		jsr	getStartAddr
f2a7 : b006             		bcs	cmdRet	;branch on bad address
f2a9 : 20d6fa           		jsr	crlf
f2ac : 6c95df           		jmp	(SAL)	;else jump to address
                        ;
f2af : 4cb7f0           cmdRet		jmp	prompt
                        ;
                        ;=====================================================
                        ; Do a hex dump of a region of memory.  This code was
                        ; taken from MICRO issue 5, from an article by
                        ; J.C. Williams.  I changed it a bit, but it's still
                        ; basically the same code.
                        ;
                        ; Slight bug: the starting address is rounded down to
                        ; a multiple of 16.  I'll fix it eventually.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- ctmon65.asm ---------------------------------

f2b2 : 2060fa           hexDump		jsr	putsil
f2b5 : 4865782064756d.. 		db	"Hex dump ",0
f2bf : 2077f7           		jsr	getAddrRange
f2c2 : b0eb             		bcs	cmdRet
                        ; jsr putsil
                        ; db "Here A",CR,LF,0
f2c4 : 20d6fa           		jsr	crlf
                        ;
                        ; Move start address to sptr but rounded down to the
                        ; 16 byte boundary.  While it's really cool to start a
                        ; the exact address specified by the user, it adds
                        ; code that really doesn't add much (any?) value.
                        ;
f2c7 : ad96df           		lda	SAH
f2ca : 85f1             		sta	sptr+1
f2cc : ad95df           		lda	SAL
f2cf : 29f0             		and	#$f0	;force to 16 byte
f2d1 : 85f0             		sta	sptr
                        ; jsr putsil
                        ; db "Here B",CR,LF,0
                        ;
                        ;-----------------------------------------------------
                        ; This starts each line.  Set flag to indcate we're
                        ; doing the hex portion, print address, etc.
                        ;
f2d3 : 20d6fa           hexdump1	jsr	crlf
f2d6 : a5f1             		lda	sptr+1
f2d8 : 20b9fa           		jsr	HexA	;print the address
                        
                        ; jsr putsil
                        ; db "Here C",CR,LF,0
f2db : a5f0             		lda	sptr
f2dd : 20b9fa           		jsr	HexA
f2e0 : 20e6fa           		jsr	space2	;two spaces after address
                        ; jsr putsil
                        ; db "Here D",CR,LF,0
                        ;
                        ;-----------------------------------------------------
                        ; This loop gets the next byte, prints the value in
                        ; hex and adds the appropriate ASCII character to the
                        ; buffer.
                        ;
f2e3 : a000             		ldy	#0	;offset from sptr
f2e5 : a200             hexdump3	ldx	#0	;bytes on line
f2e7 : b1f0             hexdump2	lda	(sptr),y	;get byte
f2e9 : 20b9fa           		jsr	HexA	;print hex version of it
f2ec : 20e9fa           		jsr	space	;space before next value
                        ;
                        ; Put the byte into the buffer
                        ;
f2ef : c920             		cmp	#' '
f2f1 : 9004             		bcc	hexdot
f2f3 : c97e             		cmp	#'~'
f2f5 : 9002             		bcc	hexpr
f2f7 : a92e             hexdot		lda	#'.'
f2f9 : 9d0adf           hexpr		sta	buffer,x	;save for later
                        ;
                        ; See if the end of the user defined area was just dum
                        ;
f2fc : a5f0             hexdumpchk	lda	sptr
f2fe : cd97df           		cmp	EAL
f301 : d007             		bne	hexdump4
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- ctmon65.asm ---------------------------------

f303 : a5f1             		lda	sptr+1
f305 : cd98df           		cmp	EAH
f308 : f00e             		beq	hexdumpend
                        ;
                        ; Not done yet, so see if at end of the line
                        ;
f30a : 2002f9           hexdump4	jsr	INCPT	;move to next address
f30d : e8               		inx
f30e : e010             		cpx	#16
f310 : d0d5             		bne	hexdump2
                        ;
                        ; At end, so dump ASCII contents
                        ;
f312 : 2021f3           		jsr	dumpbuffer
f315 : 4cd3f2           		jmp	hexdump1
                        ;
                        ; At the end but still need to dump the ASCII version.
                        ;
f318 :                  hexdumpend	;inx		;count last byte output
f318 : 2021f3           		jsr	dumpbuffer
f31b : 20d6fa           		jsr	crlf
f31e : 4cb7f0           ret1		jmp	prompt
                        
                        
                        ;
                        ;=====================================================
f321 :                  dumpbuffer
                        
f321 : e010             hexdump90	cpx	#16
f323 : f00b             		beq	hexdump91
f325 : a920             		lda	#' '
f327 : 9d0adf           		sta	buffer,x
f32a : 20e3fa           		jsr	space3
f32d : e8               		inx
f32e : d0f1             		bne	hexdump90
                        
                        
                        
f330 : 20e3fa           hexdump91	jsr	space3	;separate the two passes
f333 : a200             		ldx	#0
f335 : bd0adf           hexdump99	lda	buffer,x
f338 : 20fdfa           		jsr	cout
f33b : e8               		inx
f33c : e010             		cpx	#16
f33e : d0f5             		bne	hexdump99
f340 : 60               		rts
                        ;
                        ;=====================================================
                        ; Edit memory.  This waits for a starting address to b
                        ; entered.  It will display the current address and it
                        ; contents.  Possible user inputs and actions:
                        ;
                        ;   Two hex digits will place that value in memory
                        ;   RETURN moves to next address
                        ;   BACKSPACE moves back one address
                        ;
f341 : 2060fa           editMemory	jsr	putsil
f344 : 45646974206d65.. 		db	"Edit memory ",0
f351 : 2053f7           		jsr	getStartAddr
f354 : b0c8             		bcs	ret1
f356 : ad95df           		lda	SAL	;move address into...
f359 : 85f0             		sta	sptr	;...POINT
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- ctmon65.asm ---------------------------------

f35b : ad96df           		lda	SAH
f35e : 85f1             		sta	sptr+1
                        ;
                        ; Display the current location
                        ;
f360 : 20d6fa           editMem1	jsr	crlf
f363 : a5f1             		lda	sptr+1
f365 : 20b9fa           		jsr	HexA
f368 : a5f0             		lda	sptr
f36a : 20b9fa           		jsr	HexA
f36d : 20e9fa           		jsr	space
f370 : a000             		ldy	#0
f372 : b1f0             		lda	(sptr),y	;get byte
f374 : 20b9fa           		jsr	HexA	;print it
f377 : 20e9fa           		jsr	space
                        ;
f37a : 2019f7           		jsr	getHex
f37d : b00d             		bcs	editMem2	;not hex
f37f : a000             		ldy	#0
f381 : 91f0             		sta	(sptr),y	;save new value
                        ;
                        ; Bump POINT to next location
                        ;
f383 : e6f0             editMem3	inc	sptr
f385 : d0d9             		bne	editMem1
f387 : e6f1             		inc	sptr+1
f389 : 4c60f3           		jmp	editMem1
                        ;
                        ; Not hex, so see if another command
                        ;
f38c : c90d             editMem2	cmp	#CR
f38e : f0f3             		beq	editMem3	;move to next
f390 : c908             		cmp	#BS
f392 : d08a             		bne     ret1		;else exit
                        ;
                        ; Move back one location
                        ;
f394 : 38               		sec
f395 : a5f0             		lda	sptr
f397 : e901             		sbc	#1
f399 : 85f0             		sta	sptr
f39b : b0c3             		bcs	editMem1
f39d : c6f1             		dec	sptr+1
f39f : 4c60f3           		jmp	editMem1
                        ;
                        ;=====================================================
                        ; This handles the Load hex command.
                        ;
f3a2 : a9ff             loadHex		lda	#$ff
f3a4 : 8d05df           		sta	AutoRun+1
                        ;
f3a7 : 2060fa           		jsr	putsil
f3aa : 0d0a             		db	CR,LF
f3ac : 456e7465722066.. 		db	"Enter filename, or Enter to "
f3c8 : 6c6f6164206672.. 		db	"load from console: ",0
                        ;
f3dc : 2016f6           		jsr	getFileName	;get filename
f3df : ad9adf           		lda	filename	;null?
f3e2 : f02d             		beq	loadHexConsole	;load from console
                        ;
                        ; Open the file
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- ctmon65.asm ---------------------------------

f3e4 : a09a             		ldy	#filename&$ff
f3e6 : a2df             		ldx	#filename/256
f3e8 : 20f1fb           		jsr	DiskOpenRead
f3eb : 901e             		bcc	loadHexOk	;opened ok
                        ;
f3ed : 2060fa           openfail	jsr	putsil
f3f0 : 0d0a             		db	CR,LF
f3f2 : 4661696c656420.. 		db	"Failed to open file"
f405 : 0d0a00           		db	CR,LF,0
f408 : 4cb7f0           cmdRet3		jmp	prompt
                        ;
f40b : 20b2f9           loadHexOk	jsr	setInputFile	;redirect input
f40e : 4c3ff4           		jmp	loadStart
                        ;
                        ; They are loading from the console
                        ;
f411 : 2060fa           loadHexConsole	jsr	putsil
f414 : 0d0a             		db	CR,LF
f416 : 57616974696e67.. 		db	"Waiting for file, or ESC to"
f431 : 20657869742e2e2e 		db	" exit..."
f439 : 0d0a00           		db	CR,LF,0
f43c : 209ef9           		jsr	setInputConsole
                        ;
                        ; The start of a line.  First character should be a
                        ; colon, but toss out CRs, LFs, etc.  Anything else
                        ; causes an abort.
                        ;
f43f : 20c5f9           loadStart	jsr	redirectedGetch	;get start of line
f442 : c90d             		cmp	#CR
f444 : f0f9             		beq	loadStart
f446 : c90a             		cmp	#LF
f448 : f0f5             		beq	loadStart
f44a : c93a             		cmp	#':'	;what we expect
f44c : d034             		bne	loadAbort
                        ;
                        ; Get the header of the record
                        ;
f44e : a900             		lda	#0
f450 : 8da9df           		sta	CHKL	;initialize checksum
                        ;
f453 : 2019f7           		jsr	getHex	;get byte count
f456 : b02a             		bcs	loadAbort
f458 : 8d8fdf           		sta	SaveX	;save byte count
f45b : 205cf9           		jsr	updateCrc
f45e : 2019f7           		jsr	getHex	;get the MSB of offset
f461 : b01f             		bcs	loadAbort
f463 : 85f1             		sta	sptr+1
f465 : 205cf9           		jsr	updateCrc
f468 : 2019f7           		jsr	getHex	;get LSB of offset
f46b : b015             		bcs	loadAbort
f46d : 85f0             		sta	sptr
f46f : 205cf9           		jsr	updateCrc
f472 : 2019f7           		jsr	getHex	;get the record type
f475 : b00b             		bcs	loadAbort
f477 : 205cf9           		jsr	updateCrc
                        ;
                        ; Only handle two record types:
                        ;    00 = data record
                        ;    01 = end of file record
                        ;
f47a : c900             		cmp	#DATA_RECORD
f47c : f03a             		beq	loadDataRec
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- ctmon65.asm ---------------------------------

f47e : c901             		cmp	#EOF_RECORD
f480 : f016             		beq	loadEof
                        ;
                        ; Unknown record type
                        ;
f482 : 2060fa           loadAbort       jsr	putsil
f485 : 0d0a             		db	CR,LF
f487 : 41626f7274696e67 		db	"Aborting"
f48f : 0d0a00           		db	CR,LF,0
f492 : 209ef9           loadExit	jsr	setInputConsole
f495 : 4cb7f0           		jmp	prompt
                        ;
                        ; EOF is easy
                        ;
f498 : 2019f7           loadEof		jsr	getHex	;get checksum
f49b : 2060fa           		jsr	putsil
f49e : 0d0a             		db	CR,LF
f4a0 : 5375636365737321 		db	"Success!"
f4a8 : 0d0a00           		db	CR,LF,0
                        ;
                        ; If the auto-run vector is no longer $ffff, then jump
                        ; to whatever it points to.
                        ;
f4ab : ad05df           		lda	AutoRun+1
f4ae : c9ff             		cmp	#$ff		;unchanged?
f4b0 : f003             		beq	lExit1
f4b2 : 6c04df           		jmp	(AutoRun)	;execute!
                        ;
f4b5 : 4c92f4           lExit1		jmp	loadExit
                        ;
                        ; Data records have more work.  After processing the
                        ; line, print a dot to indicate progress.  This should
                        ; be re-thought as it could slow down loading a really
                        ; big file if the console speed is slow.
                        ;
f4b8 : ae8fdf           loadDataRec	ldx	SaveX	;byte count
f4bb : a000             		ldy	#0	;offset
f4bd : 8e8fdf           loadData1	stx	SaveX
f4c0 : 8c90df           		sty	SaveY
f4c3 : 2019f7           		jsr	getHex
f4c6 : b0ba             		bcs	loadAbort
f4c8 : 205cf9           		jsr	updateCrc
f4cb : ac90df           		ldy	SaveY
f4ce : ae8fdf           		ldx	SaveX
f4d1 : 91f0             		sta	(sptr),y
f4d3 : c8               		iny
f4d4 : ca               		dex
f4d5 : d0e6             		bne	loadData1
                        ;
                        ; All the bytes were read so get the checksum and see
                        ; if it agrees.  The checksum is a twos-complement, so
                        ; just add the checksum into what we've been calculati
                        ; and if the result is zero then the record is good.
                        ;
f4d7 : 2019f7           		jsr	getHex	;get checksum
f4da : 18               		clc
f4db : 6da9df           		adc	CHKL
f4de : d0a2             		bne	loadAbort	;non-zero is error
                        ;
f4e0 : a92e             		lda	#'.'	;sanity indicator when
f4e2 : 20fdfa           		jsr	cout	;...loading from file
f4e5 : 4c3ff4           		jmp	loadStart
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; Handles the command to save a region of memory as a
                        ; file on the SD.
                        ;
f4e8 : 2077f7           saveHex		jsr	getAddrRange	;get range to dump
f4eb : b0c8             		bcs	lExit1	;abort on error
                        ;
                        ; Get the filename to save to
                        ;
f4ed : 2060fa           		jsr	putsil
f4f0 : 0d0a             		db	CR,LF
f4f2 : 456e7465722066.. 		db	"Enter filename, or Enter to "
f50e : 6c6f6164206672.. 		db	"load from console: ",0
                        ;
f522 : 2016f6           		jsr	getFileName	;get filename
f525 : ad9adf           		lda	filename	;null?
f528 : f012             		beq	saveHexConsole	;dump to console
                        ;
                        ; They selected a file, so try to open it.
                        ;
f52a : a2df             		ldx	#filename>>8
f52c : a09a             		ldy	#filename&$ff
f52e : 2022fc           		jsr	DiskOpenWrite	;attempt to open file
f531 : 9003             		bcc	sopenok		;branch if opened ok
f533 : 4cedf3           		jmp	openfail
                        ;
f536 : 208ef9           sopenok		jsr	setOutputFile
f539 : 4c3ff5           		jmp	savehex2
                        ;
                        ; They are saving to the console.  Set up the output
                        ; vector and do the job.
                        ;
f53c : 2083f9           saveHexConsole	jsr	setOutputConsole
                        ;
                        ; Compute the number of bytes to dump
                        ;
f53f : 38               savehex2	sec
f540 : ad97df           		lda	EAL
f543 : ed95df           		sbc	SAL
f546 : 8dabdf           		sta	Temp16L
f549 : ad98df           		lda	EAH
f54c : ed96df           		sbc	SAH
f54f : 8dacdf           		sta	Temp16H
f552 : 9042             		bcc	SDone	;start > end
f554 : 0500             		ora	0
f556 : 303e             		bmi	SDone	;more than 32K seems wrong
                        ;
                        ; Add one to the count
                        ;
f558 : eeabdf           		inc	Temp16L
f55b : d003             		bne	slab1
f55d : eeacdf           		inc	Temp16H
                        ;
                        ; Move pointer to zero page
                        ;
f560 : ad95df           slab1		lda	SAL
f563 : 85f0             		sta	sptr
f565 : ad96df           		lda	SAH
f568 : 85f1             		sta	sptr+1
                        ;
                        ; Top of each loop.  Start by seeing if there are any 
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- ctmon65.asm ---------------------------------

                        ; left to dump.
                        ;
f56a : adacdf           Sloop1		lda	Temp16H
f56d : d02a             		bne	Sgo	;more to do
f56f : adabdf           		lda	Temp16L
f572 : d025             		bne	Sgo	;more to do
                        ;
                        ; At end of the region, so output an end record.  This
                        ; probably looks like overkill but keep in mind this
                        ; might be going to a file so we can't use the normal
                        ; string put functions.
                        ;
f574 : a93a             		lda	#':'
f576 : 2080f9           		jsr	redirectedOutch
f579 : a900             		lda	#0
f57b : 2066f9           		jsr	HexToOutput
f57e : 2066f9           		jsr	HexToOutput
f581 : 2066f9           		jsr	HexToOutput
f584 : a901             		lda	#1
f586 : 2066f9           		jsr	HexToOutput
f589 : a9ff             		lda	#$ff
f58b : 2066f9           		jsr	HexToOutput
                        ;
                        ; If output to file, flush and close the file.
                        ;
f58e : ad9adf           		lda	filename
f591 : f003             		beq	SDone		;it's going to console
f593 : 2051fa           		jsr	CloseOutFile
f596 : 4cb7f0           SDone		jmp	prompt		;back to the monitor
                        ;
                        ; This dumps the next line.  See how many bytes are le
                        ; and if more than BYTESLINE, then just do BYTESLINE.
                        ;
f599 : adacdf           Sgo		lda	Temp16H
f59c : d007             		bne	Sdef	;do default number of bytes
f59e : adabdf           		lda	Temp16L
f5a1 : c910             		cmp	#BYTESLINE
f5a3 : 9002             		bcc	Scnt	;more than max per line
f5a5 : a910             Sdef		lda	#BYTESLINE
f5a7 : 8d99df           Scnt		sta	tempA	;for decrementing
f5aa : 8daadf           		sta	ID	;for subtracting
                        ;
                        ; Put out the header
                        ;
f5ad : a93a             		lda	#':'
f5af : 2080f9           		jsr	redirectedOutch
                        ;
f5b2 : ad99df           		lda	tempA
f5b5 : 8da9df           		sta	CHKL	;start checksum
f5b8 : 2066f9           		jsr	HexToOutput
                        ;
f5bb : a5f1             		lda	sptr+1	;starting address
f5bd : 205cf9           		jsr	updateCrc
f5c0 : 2066f9           		jsr	HexToOutput
f5c3 : a5f0             		lda	sptr
f5c5 : 205cf9           		jsr	updateCrc
f5c8 : 2066f9           		jsr	HexToOutput
                        ;
f5cb : a900             		lda	#0	;record type - data
f5cd : 2066f9           		jsr	HexToOutput
                        ;
                        ; Now print the proper number of bytes
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- ctmon65.asm ---------------------------------

                        ;
f5d0 : a000             Sloop2		ldy	#0
f5d2 : b1f0             		lda	(sptr),y	;get byte
f5d4 : 205cf9           		jsr	updateCrc
f5d7 : 2066f9           		jsr	HexToOutput
f5da : 2002f9           		jsr	INCPT	;increment pointer
                        ;
f5dd : ce99df           sdec		dec	tempA
f5e0 : d0ee             		bne	Sloop2
                        ;
                        ; Now print checksum
                        ;
f5e2 : ada9df           		lda	CHKL
f5e5 : 49ff             		eor	#$ff	;one's complement
f5e7 : 18               		clc
f5e8 : 6901             		adc	#1	;two's complement
f5ea : 2066f9           		jsr	HexToOutput
                        ;
                        ; Output a CR/LF
                        ;
f5ed : a90d             		lda	#CR
f5ef : 2080f9           		jsr	redirectedOutch
f5f2 : a90a             		lda	#LF
f5f4 : 2080f9           		jsr	redirectedOutch
                        ;
                        ; If saving to disk, output a dot to indicate progress
                        ;
f5f7 : ad9adf           		lda	filename
f5fa : f005             		beq	shf2
                        ;
f5fc : a92e             		lda	#'.'
f5fe : 20fdfa           		jsr	cout	;goes to console
                        ;
f601 : 38               shf2		sec
f602 : adabdf           		lda	Temp16L
f605 : edaadf           		sbc	ID
f608 : 8dabdf           		sta	Temp16L
f60b : adacdf           		lda	Temp16H
f60e : e900             		sbc	#0
f610 : 8dacdf           		sta	Temp16H
                        ;
f613 : 4c6af5           		jmp	Sloop1
                        ;
                        ;=====================================================
                        ; Get a disk filename.
                        ;
f616 : a200             getFileName	ldx	#0
f618 : 200afb           getFilename1	jsr	cin	;get next key
f61b : c90d             		cmp	#CR	;end of the input?
f61d : f027             		beq	getFnDone
f61f : c908             		cmp	#BS	;backspace?
f621 : f00d             		beq	getFnDel
f623 : e00c             		cpx	#FILENAME_SIZE	;check size
f625 : f0f1             		beq	getFilename1	;at length limit
f627 : 9d9adf           		sta	filename,x	;else save it
f62a : 20fdfa           		jsr	cout
f62d : e8               		inx
f62e : d0e8             		bne	getFilename1
                        ;
f630 : ca               getFnDel	dex
f631 : 3010             		bmi	getFnU	;no charac here
f633 : a908             		lda	#BS
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- ctmon65.asm ---------------------------------

f635 : 20fdfa           		jsr	cout
f638 : a920             		lda	#' '
f63a : 20fdfa           		jsr	cout
f63d : a908             		lda	#BS
f63f : 20fdfa           		jsr	cout
f642 : ca               		dex
f643 : e8               getFnU		inx		;can't go past start
f644 : 10d2             		bpl	getFilename1
f646 : a900             getFnDone       lda	#0	;terminate line
f648 : 9d9adf           		sta	filename,x
f64b : 4cd6fa           		jmp	crlf
                        ;
                        ;=====================================================
                        ; Add the byte in A to the output buffer.  If the
                        ; buffer is full, flush it to disk.
                        ;
f64e : aea7df           putNextFileByte	ldx	diskBufOffset
f651 : e084             		cpx	#BUFFER_SIZE	;buffer full?
f653 : d00d             		bne	pNFB		;no
                        ;
                        ; The buffer is full, so write it out.
                        ;
f655 : 48               		pha			;save byte
f656 : a984             		lda	#BUFFER_SIZE
f658 : a2df             		ldx	#buffer>>8
f65a : a00a             		ldy	#buffer&$ff
f65c : 2059fc           		jsr	DiskWrite
                        ;
f65f : a200             		ldx	#0		;reset index
f661 : 68               		pla
f662 : 9d0adf           pNFB		sta	buffer,x
f665 : e8               		inx
f666 : 8ea7df           		stx	diskBufOffset
f669 : 60               		rts
                        ;
                        ;*****************************************************
                        ; Dump the current registers based on values in the Sa
                        ; locations.
                        ;
f66a : 2060fa           DumpRegisters	jsr	putsil
f66d : 50433a00         		db	"PC:",0
f671 : ad92df           		lda	SavePC+1
f674 : 20b9fa           		jsr	HexA
f677 : ad91df           		lda	SavePC
f67a : 20b9fa           		jsr	HexA
                        ;
f67d : 2060fa           		jsr	putsil
f680 : 20413a00         		db	" A:",0
f684 : ad8edf           		lda	SaveA
f687 : 20b9fa           		jsr	HexA
                        ;
f68a : 2060fa           		jsr	putsil
f68d : 20583a00         		db	" X:",0
f691 : ad8fdf           		lda	SaveX
f694 : 20b9fa           		jsr	HexA
                        ;
f697 : 2060fa           		jsr	putsil
f69a : 20593a00         		db	" Y:",0
f69e : ad90df           		lda	SaveY
f6a1 : 20b9fa           		jsr	HexA
                        ;
f6a4 : 2060fa           		jsr	putsil
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- ctmon65.asm ---------------------------------

f6a7 : 2053503a00       		db	" SP:",0
f6ac : ad94df           		lda	SaveSP
f6af : 20b9fa           		jsr	HexA
                        ;
                        ; Last is the condition register.  For this, print the
                        ; actual flags.  Lower case for clear, upper for set.
                        ;
f6b2 : 2060fa           		jsr	putsil
f6b5 : 20466c6167733a00 		db	" Flags:",0
                        	if	FULL_STATUS
                        ;
                        ; N - bit 7
                        ;
f6bd : a980             		lda	#$80	;bit to test
f6bf : a24e             		ldx	#'N'	;set ACII char
f6c1 : 20f0f6           		jsr	testbit
                        ;
                        ; V - bit 6
                        ;
f6c4 : a940             		lda	#$40	;bit to test
f6c6 : a256             		ldx	#'V'	;set ACII char
f6c8 : 20f0f6           		jsr	testbit
                        ;
f6cb : a92d             		lda	#'-'	;unused bit
f6cd : 20fdfa           		jsr	cout
                        ;
                        ; B - bit 4
                        ;
f6d0 : a910             		lda	#$10	;bit to test
f6d2 : a242             		ldx	#'B'	;set ACII char
f6d4 : 20f0f6           		jsr	testbit
                        ;
                        ; D - bit 3
                        ;
f6d7 : a908             		lda	#$08	;bit to test
f6d9 : a244             		ldx	#'D'	;set ACII char
f6db : 20f0f6           		jsr	testbit
                        ;
                        ; I - bit 2
                        ;
f6de : a904             		lda	#$04	;bit to test
f6e0 : a249             		ldx	#'I'	;set ACII char
f6e2 : 20f0f6           		jsr	testbit
                        ;
                        ; Z - bit 1
                        ;
f6e5 : a902             		lda	#$02	;bit to test
f6e7 : a25a             		ldx	#'Z'	;set ACII char
f6e9 : 20f0f6           		jsr	testbit
                        ;
                        ; C - bit 0
                        ;
f6ec : a901             		lda	#$01	;bit to test
f6ee : a243             		ldx	#'C'	;set ACII char
                        ;
                        ; Fall through...
                        ;
                        ;*****************************************************
                        ; Given a bit mask in A and an upper case character
                        ; indicating the flag name in X, see if the flag is se
                        ; not.  Output upper case if set, lower case if not.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- ctmon65.asm ---------------------------------

f6f0 : 2d93df           testbit		and	SaveC	;is bit set?
f6f3 : d006             		bne	testbit1	;yes
f6f5 : 8a               		txa
f6f6 : 0920             		ora	#$20	;make lower case
f6f8 : 4cfdfa           		jmp	cout
f6fb : 8a               testbit1	txa
f6fc : 4cfdfa           		jmp	cout
                        	else
                        		lda	SaveSP
                        		jmp	HexA
                        	endif
                        ;
                        ;=====================================================
                        ; This continues executing from the last saved state,
                        ; such as from a call to DefaultNMI.
                        ;
f6ff :                  doContinue
f6ff : ae94df           		ldx	SaveSP
f702 : 9a               		txs
f703 : ad92df           		lda	SavePC+1
f706 : 48               		pha
f707 : ad91df           		lda	SavePC
f70a : 48               		pha
f70b : ad93df           		lda	SaveC
f70e : 48               		pha
f70f : ae8fdf           		ldx	SaveX
f712 : ac90df           		ldy	SaveY
f715 : ad8edf           		lda	SaveA
f718 : 40               		rti
                        ;
                        ;=====================================================
                        ; This gets two hex characters and returns the value
                        ; in A with carry clear.  If a non-hex digit is
                        ; entered, then A contans the offending character and
                        ; carry is set.
                        ;
f719 : 2031f7           getHex		jsr	getNibble
f71c : b020             		bcs	getNibBad
f71e : 0a               		asl	a
f71f : 0a               		asl	a
f720 : 0a               		asl	a
f721 : 0a               		asl	a
f722 : 29f0             		and	#$f0
f724 : 8d99df           		sta	tempA
f727 : 2031f7           		jsr	getNibble
f72a : b012             		bcs	getNibBad
f72c : 0d99df           		ora	tempA
f72f : 18               		clc
f730 : 60               		rts
                        ;
                        ; Helper.  Gets next input char and converts to a
                        ; value from 0-F in A and returns C clear.  If not a
                        ; valid hex character, return C set.
                        ;
f731 : 20c5f9           getNibble	jsr	redirectedGetch
f734 : a20f             		ldx	#nibbleHexEnd-nibbleHex-1
f736 : dd43f7           getNibble1	cmp	nibbleHex,x
f739 : f005             		beq	getNibF	;got match
f73b : ca               		dex
f73c : 10f8             		bpl	getNibble1
f73e : 38               getNibBad	sec
f73f : 60               		rts
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- ctmon65.asm ---------------------------------

                        
f740 : 8a               getNibF		txa		;index is value
f741 : 18               		clc
f742 : 60               		rts
                        ;
f743 : 30313233343536.. nibbleHex	db	"0123456789ABCDEF"
f753 =                  nibbleHexEnd	equ	*
                        ;
                        ;=====================================================
                        ; Gets a four digit hex address amd places it in
                        ; SAL and SAH.  Returns C clear if all is well, or C
                        ; set on error and A contains the character.
                        ;
f753 : 2019f7           getStartAddr	jsr	getHex
f756 : b00c             		bcs	getDone
f758 : 8d96df           		sta	SAH
f75b : 2019f7           		jsr	getHex
f75e : b004             		bcs	getDone
f760 : 8d95df           		sta	SAL
f763 : 18               		clc
f764 : 60               getDone		rts
                        ;
                        ;=====================================================
                        ; Gets a four digit hex address and places it in
                        ; EAL and EAH.  Returns C clear if all is well, or C
                        ; set on error and A contains the character.
                        ;
f765 : 2019f7           getEndAddr	jsr	getHex
f768 : b0fa             		bcs	getDone
f76a : 8d98df           		sta	EAH
f76d : 2019f7           		jsr	getHex
f770 : b0f2             		bcs	getDone
f772 : 8d97df           		sta	EAL
f775 : 18               		clc
f776 : 60               		rts
                        ;
                        ;=====================================================
                        ; Get an address range and leave them in SAL and EAL.
                        ;
f777 : 2060fa           getAddrRange	jsr	putsil
f77a : 53746172743a2000 		db	"Start: ",0
f782 : 2053f7           		jsr	getStartAddr
f785 : b0dd             		bcs	getDone
f787 : 2060fa           		jsr	putsil
f78a : 2c20456e643a2000 		db	", End: ",0
f792 : 2065f7           		jsr	getEndAddr
f795 : 60               		rts
                        ;
                        ;=====================================================
                        ; Command handler for the ? command
                        ;
f796 : 2060fa           showHelp	jsr	putsil
f799 : 0d0a             		db	CR,LF
f79b : 417661696c6162.. 		db	"Available commands:"
f7ae : 0d0a0a00         		db	CR,LF,LF,0
                        ;
                        ; Print help for built-in commands...
                        ;
f7b2 : a9f3             		lda	#commandTable&$ff
f7b4 : 85f0             		sta	sptr
f7b6 : a9f0             		lda	#commandTable/256
f7b8 : 85f1             		sta	sptr+1
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- ctmon65.asm ---------------------------------

f7ba : 20c0f7           		jsr	displayHelp	;display help
                        ;
                        ; Now print help for the extension commands...
                        ;
                        	if	EXTENDED_CMDS
                        		lda	ExtensionAddr
                        		sta	sptr
                        		lda	ExtensionAddr+1
                        		sta	sptr+1
                        		jsr	displayHelp
                        		jsr	crlf
                        	endif
f7bd : 4cb7f0           		jmp	prompt
                        ;
                        ;=====================================================
                        ; Given a pointer to a command table in POINT, display
                        ; the help text for all commands in the table.
                        ;
f7c0 : a000             displayHelp	ldy	#0	;index into command table
f7c2 : b1f0             showHelpLoop	lda	(sptr),y	;get command
f7c4 : f01c             		beq	showHelpDone	;jump if at end
                        ;
                        ; Display this entry's descriptive text
                        ;
f7c6 : c8               		iny		;skip over command
f7c7 : c8               		iny		;skip over function ptr
f7c8 : c8               		iny
f7c9 : b1f0             		lda	(sptr),y
f7cb : 85f2             		sta	INL
f7cd : c8               		iny
f7ce : b1f0             		lda	(sptr),y
f7d0 : 85f3             		sta	INH
f7d2 : 98               		tya
f7d3 : 48               		pha
f7d4 : 20e6fa           		jsr	space2
f7d7 : 2083fa           		jsr	puts	;print description
f7da : 20d6fa           		jsr	crlf
f7dd : 68               		pla
f7de : a8               		tay
f7df : c8               		iny		;point to next entry
f7e0 : d0e0             		bne	showHelpLoop
f7e2 : 60               showHelpDone	rts
                        ;
                        ;=====================================================
                        ; This does a memory test of a region of memory.
                        ;
                        ; Asks for the starting and ending locations.
                        ;
                        ; This cycles a rolling bit, then adds a ninth
                        ; pattern to help detect shorted address bits.
                        ; Ie: 01, 02, 04, 08, 10, 20, 40, 80, BA
                        ;
df8e =                  pattern		equ	SaveA	;re-use some other locations
df8f =                  original	equ	SaveX
                        ;
                        ; Test patterns
                        ;
0001 =                  PATTERN_0	equ	$01
00ba =                  PATTERN_9	equ	$ba
                        ;
f7e3 : 200afb           memabort	jsr	cin	;eat pending key
f7e6 : 4cb7f0           cmdRet2		jmp	prompt
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- ctmon65.asm ---------------------------------

                        ;
f7e9 : 2060fa           memTest		jsr	putsil
f7ec : 4d656d6f727920.. 		db	"Memory test ",0
f7f9 : 2077f7           		jsr	getAddrRange	;get range
f7fc : b0e8             		bcs	cmdRet2		;branch if abort
                        ;
f7fe : 2060fa           		jsr	putsil
f801 : 0d0a             		db	CR,LF
f803 : 54657374696e67.. 		db	"Testing memory.  Press any key to abort"
f82a : 00               		db	0
f82b : a901             		lda	#PATTERN_0	;only set initial...
f82d : 8d8edf           		sta	pattern		;..pattern once
                        ;
                        ; Start of loop.  This fills/tests one complete pass
                        ; of memory.
                        ;
f830 : 2015fb           memTestMain	jsr	cstatus	;key pressed?
f833 : d0ae             		bne	memabort	;branch if yes
f835 : ad95df           		lda	SAL	;reset pointer to start
f838 : 85f0             		sta	sptr
f83a : ad96df           		lda	SAH
f83d : 85f1             		sta	sptr+1
                        ;
                        ; Fill memory with the rolling pattern until the last
                        ; location is filled.
                        ;
f83f : a000             		ldy	#0
f841 : ad8edf           		lda	pattern
f844 : 8d8fdf           		sta	original
f847 : 91f0             memTestFill	sta	(sptr),y
f849 : c9ba             		cmp	#PATTERN_9	;at last pattern?
f84b : d005             		bne	memFill3
f84d : a901             		lda	#PATTERN_0	;restart pattern
f84f : 4c57f8           		jmp	memFill4
                        ;
                        ; Rotate pattern left one bit
                        ;
f852 : 0a               memFill3	asl	a
f853 : 9002             		bcc	memFill4	;branch if not overflow
f855 : a9ba             		lda	#PATTERN_9	;ninth pattern
                        ;
                        ; The new pattern is in A.  Now see if we've reached
                        ; the end of the area to be tested.
                        ;
f857 : 48               memFill4	pha		;save pattern
f858 : a5f0             		lda	sptr
f85a : cd97df           		cmp	EAL
f85d : d007             		bne	memFill5
f85f : a5f1             		lda	sptr+1
f861 : cd98df           		cmp	EAH
f864 : f007             		beq	memCheck
                        ;
                        ; Not done, so move to next address and keep going.
                        ;
f866 : 2002f9           memFill5	jsr	INCPT
f869 : 68               		pla		;recover pattern
f86a : 4c47f8           		jmp	memTestFill
                        ;
                        ; Okay, memory is filled, so now go back and test it.
                        ; We kept a backup copy of the initial pattern to
                        ; use, but save the current pattern as the starting
                        ; point for the next pass.
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- ctmon65.asm ---------------------------------

                        ;
f86d : 68               memCheck	pla
f86e : 8d8edf           		sta	pattern	;for next pass
f871 : ad95df           		lda	SAL	;reset pointer to start
f874 : 85f0             		sta	sptr
f876 : ad96df           		lda	SAH
f879 : 85f1             		sta	sptr+1
f87b : ad8fdf           		lda	original	;restore initial pattern
f87e : a000             		ldy	#0
f880 : d1f0             memTest2	cmp	(sptr),y
f882 : d02c             		bne	memFail
f884 : c9ba             		cmp	#PATTERN_9
f886 : d004             		bne	memTest3
                        ;
                        ; Time to reload the pattern
                        ;
f888 : a901             		lda	#PATTERN_0
f88a : d005             		bne	memTest4
                        ;
                        ; Rotate pattern left one bit
                        ;
f88c : 0a               memTest3	asl	a
f88d : 9002             		bcc	memTest4
f88f : a9ba             		lda	#PATTERN_9
                        ;
                        ; The new pattern is in A.
                        ;
f891 : 48               memTest4	pha		;save pattern
f892 : a5f0             		lda	sptr
f894 : cd97df           		cmp	EAL
f897 : d007             		bne	memTest5	;not at end
f899 : a5f1             		lda	sptr+1
f89b : cd98df           		cmp	EAH
f89e : f007             		beq	memDone	;at end of pass
                        ;
                        ; Not at end yet, so inc pointer and continue
                        ;
f8a0 : 2002f9           memTest5	jsr	INCPT
f8a3 : 68               		pla
f8a4 : 4c80f8           		jmp	memTest2
                        ;
                        ; Another pass has completed.
                        ;
f8a7 : 68               memDone		pla
f8a8 : a92e             		lda	#'.'
f8aa : 20fdfa           		jsr	cout
f8ad : 4c30f8           		jmp	memTestMain
                        ;
                        ; Failure.  Display the failed address, the expected
                        ; value and what was actually there.
                        ;
f8b0 : 48               memFail		pha		;save pattern for error report
f8b1 : 2060fa           		jsr	putsil
f8b4 : 0d0a             		db	CR,LF
f8b6 : 4661696c757265.. 		db	"Failure at address ",0
f8ca : a5f1             		lda	sptr+1
f8cc : 20b9fa           		jsr	HexA
f8cf : a5f0             		lda	sptr
f8d1 : 20b9fa           		jsr	HexA
f8d4 : 2060fa           		jsr	putsil
f8d7 : 2e202045787065.. 		db	".  Expected ",0
f8e4 : 68               		pla
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- ctmon65.asm ---------------------------------

f8e5 : 20b9fa           		jsr	HexA
f8e8 : 2060fa           		jsr	putsil
f8eb : 2062757420676f.. 		db	" but got ",0
f8f5 : a000             		ldy	#0
f8f7 : b1f0             		lda	(sptr),y
f8f9 : 20b9fa           		jsr	HexA
f8fc : 20d6fa           		jsr	crlf
f8ff : 4cb7f0           cmdRet4		jmp	prompt
                        ;
                        ;=====================================================
                        ; Increment sptr
                        ;
f902 : e6f0             INCPT		inc	sptr
f904 : d002             		bne	incpt2
f906 : e6f1             		inc	sptr+1
f908 : 60               incpt2		rts
                        ;
                        ;=====================================================
                        ; Ping the Arduino disk controller.  This just sends t
                        ; PING command gets back one character, then returns.
                        ; Not much of a test but is sufficient to prove the
                        ; link is working.
                        ;
f909 : 2060fa           pingDisk	jsr	putsil
f90c : 50696e672e2e2e.. 		db	"Ping... ",0
f915 : 20a3fb           		jsr	DiskPing
f918 : 2060fa           		jsr	putsil
f91b : 7375636365737321 		db	"success!"
f923 : 0d0a00           		db	CR,LF,0
f926 : 4cb7f0           doDiskDirEnd	jmp	prompt
                        ;
                        ;=====================================================
                        ; Do a disk directory of the SD card.
                        ;
f929 : 2060fa           doDiskDir	jsr	putsil
f92c : 4469736b204469.. 		db	"Disk Directory..."
f93d : 0d0a00           		db	CR,LF,0
                        ;		jsr	xParInit
f940 : 20b6fb           		jsr	DiskDir
                        ;
                        ; Get/Display each entry
                        ;
f943 : a2df             doDiskDirLoop   ldx	#filename/256	;pointer to buffer
f945 : a09a             		ldy	#filename&$ff
f947 : 86f3             		stx	INH		;save for puts
f949 : 84f2             		sty	INL
f94b : 20c0fb           		jsr	DiskDirNext	;get next entry
f94e : b0d6             		bcs	doDiskDirEnd	;carry = end of list
f950 : 20e3fa           		jsr	space3
f953 : 2083fa           		jsr	puts		;else print name
f956 : 20d6fa           		jsr	crlf
f959 : 4c43f9           		jmp	doDiskDirLoop	;do next entry
                        ;
                        ;=====================================================
                        ; Adds the character in A to the CRC.  Preserves A.
                        ;
f95c : 48               updateCrc	pha
f95d : 18               		clc
f95e : 6da9df           		adc	CHKL
f961 : 8da9df           		sta	CHKL
f964 : 68               		pla
f965 : 60               		rts
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; Print character in A as two hex digits to the
                        ; current output device (console or file).
                        ;
f966 : 48               HexToOutput	pha		;save return value
f967 : 48               		pha
f968 : 4a               		lsr	a	;move top nibble to bottom
f969 : 4a               		lsr	a
f96a : 4a               		lsr	a
f96b : 4a               		lsr	a
f96c : 2075f9           		jsr	hexta	;output nibble
f96f : 68               		pla
f970 : 2075f9           		jsr	hexta
f973 : 68               		pla		;restore
f974 : 60               		rts
                        ;
f975 : 290f             hexta		and	#%0001111
f977 : c90a             		cmp	#$0a
f979 : 18               		clc
f97a : 3002             		bmi	hexta1
f97c : 6907             		adc	#7
f97e : 6930             hexta1		adc	#'0'	;then fall into...
                        ;
                        ;=====================================================
                        ; This is a helper function used for redirected I/O.
                        ; It simply does a jump through the output vector
                        ; pointer to send the character in A to the proper
                        ; device.
                        ;
f980 : 6c08df           redirectedOutch	jmp	(outputVector)
                        ;
                        ;=====================================================
                        ; Set up the output vector to point to the normal
                        ; console output subroutine.
                        ;
f983 :                  setOutputConsole
f983 : a9fd             		lda	#cout&$ff
f985 : 8d08df           		sta     outputVector
f988 : a9fa             		lda	#cout/256
f98a : 8d09df           		sta	outputVector+1
f98d : 60               		rts
                        ;
                        ;=====================================================
                        ; Set up the output vector to point to a file write
                        ; subroutine.
                        ;
f98e : a94e             setOutputFile	lda	#putNextFileByte&$ff
f990 : 8d08df           		sta     outputVector
f993 : a9f6             		lda	#putNextFileByte/256
f995 : 8d09df           		sta	outputVector+1
                        ;
                        ; Clear counts and offsets so the next read will
                        ; cause the file to be read.
                        ;
f998 : a900             		lda	#0
f99a : 8da7df           		sta	diskBufOffset
f99d : 60               		rts
                        ;
                        ;=====================================================
                        ; Set up the input vector to point to the normal
                        ; console input subroutine.
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- ctmon65.asm ---------------------------------

                        ;
f99e : a9a9             setInputConsole	lda	#cinecho&$ff
f9a0 : 8d06df           		sta     inputVector
f9a3 : a9f9             		lda	#cinecho/256
f9a5 : 8d07df           		sta	inputVector+1
f9a8 : 60               		rts
                        ;
f9a9 : 200afb           cinecho		jsr	cin
f9ac : 48               		pha
f9ad : 20fdfa           		jsr	cout
f9b0 : 68               		pla
f9b1 : 60               		rts
                        ;
                        ;=====================================================
                        ; Set up the input vector to point to a file read
                        ; subroutine.
                        ;
f9b2 : a9c8             setInputFile    lda	#getNextFileByte&$ff
f9b4 : 8d06df           		sta     inputVector
f9b7 : a9f9             		lda	#getNextFileByte/256
f9b9 : 8d07df           		sta	inputVector+1
                        ;
                        ; Clear counts and offsets so the next read will
                        ; cause the file to be read.
                        ;
f9bc : a900             		lda	#0
f9be : 8da7df           		sta	diskBufOffset
f9c1 : 8da8df           		sta	diskBufLength
f9c4 : 60               		rts
                        ;
                        ;=====================================================
                        ; This is a helper function used for redirected I/O.
                        ; It simply does a jump through the input vector
                        ; pointer to get the next input character.
                        ;
f9c5 : 6c06df           redirectedGetch	jmp	(inputVector)
                        ;
                        ;=====================================================
                        ; This gets the next byte from an open disk file.  If
                        ; there are no more bytes left, this returns C set.
                        ; Else, C is clear and A contains the character.
                        ;
f9c8 : aea7df           getNextFileByte ldx 	diskBufOffset
f9cb : eca8df           		cpx	diskBufLength
f9ce : d014             		bne	hasdata		;branch if still data
                        ;
                        ; There is no data left in the buffer, so read a
                        ; block from the SD system.
                        ;
f9d0 : a984             		lda	#BUFFER_SIZE
f9d2 : a2df             		ldx	#buffer>>8
f9d4 : a00a             		ldy	#buffer&$ff
f9d6 : 2027fc           		jsr	DiskRead
f9d9 : b012             		bcs	getNextEof
                        ;
                        ; A contains the number of bytes actually read.
                        ;
f9db : 8da8df           		sta	diskBufLength	;save length
f9de : c900             		cmp	#0		;shouldn't happen
f9e0 : f00b             		beq	getNextEof
                        ;
f9e2 : a200             		ldx	#0
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- ctmon65.asm ---------------------------------

f9e4 : bd0adf           hasdata		lda	buffer,x
f9e7 : e8               		inx
f9e8 : 8ea7df           		stx	diskBufOffset
f9eb : 18               		clc
f9ec : 60               		rts
                        ;
f9ed : a900             getNextEof	lda	#0
f9ef : 8da7df           		sta	diskBufOffset
f9f2 : 8da8df           		sta	diskBufLength
f9f5 : 38               		sec
f9f6 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; Type the contents of an SD file to console.
                        ;
f9f7 : 2060fa           typeFile	jsr	putsil
f9fa : 456e7465722066.. 		db	"Enter filename to type: ",0
fa13 : 2016f6           		jsr	getFileName
fa16 : a09a             		ldy	#filename&$ff
fa18 : a2df             		ldx	#filename/256
                        ;		jsr	xParInit
fa1a : 20f1fb           		jsr	DiskOpenRead
fa1d : 901e             		bcc	typeFile1	;opened ok
                        ;
fa1f : 2060fa           		jsr	putsil
fa22 : 0d0a             		db	CR,LF
fa24 : 4661696c656420.. 		db	"Failed to open file"
fa37 : 0d0a00           		db	CR,LF,0
fa3a : 4cb7f0           		jmp	prompt
                        ;
                        ; Now just keep reading in bytes and displaying them.
                        ;
fa3d : 20b2f9           typeFile1	jsr	setInputFile	;reading from file
fa40 : 20c8f9           typeFileLoop	jsr	getNextFileByte
fa43 : b006             		bcs	typeEof
fa45 : 20fdfa           		jsr	cout	;display character
fa48 : 4c40fa           		jmp	typeFileLoop
                        ;
fa4b : 2090fc           typeEof		jsr	DiskClose
fa4e : 4cb7f0           		jmp	prompt
                        ;
                        ;=====================================================
                        ; This flushes any data remaining in the disk buffer
                        ; and then closes the file.
                        ;
fa51 : ada7df           CloseOutFile	lda	diskBufOffset
fa54 : f007             		beq	closeonly
fa56 : a2df             		ldx	#buffer>>8
fa58 : a00a             		ldy	#buffer&$ff
fa5a : 2059fc           		jsr	DiskWrite
                        ;
fa5d : 4c90fc           closeonly	jmp	DiskClose
                        ;
                        		include	"io.asm"
                        ;*****************************************************
                        ; FILE: io.asm
                        ;
                        ; This contains slightly higher level console related
                        ; functions like text output, reading a line, etc.
                        ;*****************************************************
                        ;
                        ;		zpage
                        ;putsp		ds	2
                        ;
                        		bss
dfad =                  BUFFER		ds	BUFFER_SIZE
e031 =                  argc		ds	1
e032 =                  argv		ds	MAX_ARGC
                        ;
                        		code
                        ;
                        ;*****************************************************
                        ; Print the string that follows the JSR to this code.
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- ctmon65.asm ---------------------------------

                        ; Taken from http://www.6502.org/source/io/primm.htm
                        ; The last example by Ross Archer.
                        ;
fa60 : 68               putsil		pla		;Get the low part of "return" address
                        				;(data start address)
fa61 : 85f4             		sta	putsp
fa63 : 68               		pla
fa64 : 85f5             		sta	putsp+1	;Get the high part of "return" address
                        				;(data start address)
                        				;Note: actually we're pointing one short
fa66 : a001             PSINB		ldy	#1
fa68 : b1f4             		lda	(putsp),y	;Get the next string character
fa6a : e6f4             		inc	putsp	;update the pointer
fa6c : d002             		bne	PSICHO	;if not, we're pointing to next character
fa6e : e6f5             		inc	putsp+1	;account for page crossing
fa70 : 0900             PSICHO		ora	#0	;Set flags according to contents of
                        				;   Accumulator
fa72 : f006             		beq	PSIX1	;don't print the final NULL
fa74 : 20fdfa           		jsr	cout	;write it out
fa77 : 4c66fa           		jmp	PSINB	;back around
fa7a : e6f4             PSIX1		inc	putsp
fa7c : d002             		bne	PSIX2
fa7e : e6f5             		inc	putsp+1	;account for page crossing
fa80 : 6cf400           PSIX2		jmp	(putsp)	;return to byte following final NUL
                        ;
                        ;=====================================================
                        ; This prints the null terminated string pointed to by
                        ; INL and INH.  Modifies those locations to point to
                        ; the end of the string.
                        ;
fa83 : a000             puts		ldy	#0
fa85 : b1f2             putsy		lda	(INL),y
fa87 : e6f2             		inc	INL
fa89 : d002             		bne	puts1
fa8b : e6f3             		inc	INH
fa8d : 0900             puts1		ora	#0
fa8f : f00c             		beq	putsdone
fa91 : 8c90df           		sty	SaveY
fa94 : 20fdfa           		jsr	cout	;print character
fa97 : ac90df           		ldy	SaveY
fa9a : 4c85fa           		jmp	putsy
fa9d : 60               putsdone	rts
                        ;
                        ;*****************************************************
                        ; Get a line of text from the console and put it into
                        ; BUFFER.  This only allows printable characters, will
                        ; limit the amount of text to BUFFER_SIZE-1 characters
                        ; and allows some editing.  Returns the string with a 
                        ; byte at the end and the length in A.  If the length 
                        ; zero, return Z set.
                        ;
fa9e :                  getline
                        	if 0
                        		ldx	#0
                        		beq	getline1
                        ;
                        ; This outputs a bell.  Used when the user
                        ; does something bad, like non-printable
                        ; characters or exceeding line length.
                        ;
                        getline2	lda	#BELL
                        		jsr	cout
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ; Get the next character
                        ;
                        getline1	jsr	cin	;get character
                        		cmp	#' '
                        		bcc	getline2	;not printable
                        		cmp	#'~'+1
                        		bcs	getline2	;not printable
                        		cmp	#CR	;end of input?
                        		beq	getline3
                        		cpx	#BUFFER_SIZE-1
                        		beq	getline1	;too long
                        		sta	BUFFER,x
                        		jsr	cout	;echo, echo, echo...
                        		inx
                        		bne	getline1
                        ;
                        ; Got a CR, so terminate the string.
                        ;
                        getline3	lda	#0
                        		sta	BUFFER,x
                        		txa		;will set/clear Z
                        	endif
fa9e : 60               		rts
                        ;
                        ;*****************************************************
                        ; This converts the buffer to all lower case.
                        ;
fa9f : a200             ToLower		ldx	#0
faa1 : bdaddf           ToLower1	lda	BUFFER,x
faa4 : f011             		beq	ToLowerDone
                        ;
faa6 : c961             		cmp	#'a'
faa8 : 900a             		bcc	ToLower2
faaa : c97b             		cmp	#'z'+1
faac : b006             		bcs	ToLower2
faae : 18               		clc
faaf : e920             		sbc	#$20	;convert
fab1 : 9daddf           		sta	BUFFER,x
fab4 : e8               ToLower2	inx
fab5 : d0ea             		bne	ToLower1
                        ;
fab7 : 60               ToLowerDone	rts
                        ;
                        ;*****************************************************
                        ; This parses the current contents of BUFFER.  It scan
                        ; until finding whitespace, terminates the string (put
                        ; null), then scans until finding the next non-whitesp
                        ; and repeats the process again.  Saves the offset to 
                        ; word in argc, and has a total count in argv.  Yes, I
                        ; a C programmer.
                        ;
fab8 :                  parse
                        	if 0
                        		ldx	#0
                        		stx	argc	;clear count
                        		dex
                        ;
                        ; Skip whitespace
                        ;
                        parse1		inx
                        		lda	BUFFER,x
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- ctmon65.asm ---------------------------------

                        		beq	parse2	;at EOL
                        		cmp	#' '
                        		beq	parse1	;whitespace
                        ;
                        ; Not whitespace
                        ;
                        		ldy	argc
                        		stx	argv,y
                        		iny
                        		cpy	#MAX_ARGC
                        		beq	parse2
                        		sty	argv
                        ;
                        ; Now skip until whitespace found again
                        ;
                        parse3		inx
                        		lda	BUFFER,x
                        		beq	parse2
                        		cmp	#' '
                        		bne	parse3
                        		lda	#0
                        		sta	BUFFER,x	;terminate
                        		jmp	parse1
                        ;
                        	endif
fab8 : 60               parse2		rts
                        ;
                        ;*****************************************************
                        ; Dump the contents of A as two hex digits.  Preserves
                        ; all registers.
                        ;
fab9 : 48               HexA		pha		;save value
faba : 48               		pha
fabb : 4a               		lsr	a
fabc : 4a               		lsr	a
fabd : 4a               		lsr	a
fabe : 4a               		lsr	a
fabf : 20c8fa           		jsr	HexDigit
fac2 : 68               		pla
fac3 : 20c8fa           		jsr	HexDigit
fac6 : 68               		pla		;restore value
fac7 : 60               		rts
                        ;
fac8 : 290f             HexDigit	and	#$0f
faca : c90a             		cmp	#$0a
facc : 18               		clc
facd : 3002             		bmi	HexDigit1
facf : 6907             		adc	#7
fad1 : 6930             HexDigit1	adc	#'0'
fad3 : 4cfdfa           		jmp	cout
                        ;
                        ;*****************************************************
                        ; Output a CR/LF combination to the console.  Preserve
                        ; all registers.
                        ;
fad6 : 48               crlf		pha
fad7 : a90d             		lda	#CR
fad9 : 20fdfa           		jsr	cout
fadc : a90a             		lda	#LF
fade : 20fdfa           		jsr	cout
fae1 : 68               		pla
fae2 : 60               		rts
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;*****************************************************
                        ; Output one, two or three spaces.  Preserves all
                        ; register.
                        ;
fae3 : 20e9fa           space3		jsr	space
fae6 : 20e9fa           space2		jsr	space
fae9 : 48               space		pha
faea : a920             		lda	#' '
faec : 20fdfa           		jsr	cout
faef : 68               		pla
faf0 : 60               		rts
                        
                        
                        
                        		include	"acia.asm"
                        ;*****************************************************
                        ; FILE: acia.asm
                        ;*****************************************************
                        ;
0001 =                  CONSOLE_SLOT	equ	1
                        ;
e010 =                  ACIA		equ	(CONSOLE_SLOT*IO_SIZE)+IO_BASE
0001 =                  RDRF		equ	%00000001
0002 =                  TDRE		equ	%00000010
                        ;
                        ;*****************************************************
                        ; Initialize the ACIA
                        ;
faf1 : a903             cinit		lda	#%00000011	;reset
faf3 : 8d10e0           		sta	ACIA
faf6 : ea               		nop
faf7 : a911             		lda	#%00010001	;8N2
faf9 : 8d10e0           		sta	ACIA
fafc : 60               		rts
                        ;
                        ;*****************************************************
                        ; Output the character in A to the console.  This will
                        ; block until the character is queued.  Preserves all
                        ; registers.
                        ;
fafd : 48               cout		pha
fafe : ad10e0           cout1		lda	ACIA
fb01 : 2902             		and	#TDRE
fb03 : f0f9             		beq	cout1		;not empty
fb05 : 68               		pla
fb06 : 8d11e0           		sta	ACIA+1
fb09 : 60               		rts
                        ;
                        ;*****************************************************
                        ; Gets a character from the console and returns it in 
                        ; Modifies no other registers.  This blocks until a
                        ; character is available.
                        ;
fb0a : ad10e0           cin		lda	ACIA
fb0d : 2901             		and	#RDRF
fb0f : f0f9             		beq	cin
fb11 : ad11e0           		lda	ACIA+1
fb14 : 60               		rts
                        ;
                        ;*****************************************************
                        ; Get the status of the console.  Returns Z set if no
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- ctmon65.asm ---------------------------------

                        ; characters are available, Z clear if a character is
                        ; ready.
                        ;
fb15 : ad10e0           cstatus		lda	ACIA
fb18 : 2901             		and	#RDRF
fb1a : 60               		rts
                        
                        	if SD_ENABLED
                        		include	"parproto.inc"
                        ;*****************************************************
                        ; Parallel port protocol
                        ;
                        ; This is the header file for making applications
                        ; compliant with The Remote Disk Protocol Guide which
                        ; is on the Corsham Technologies web page somewhere:
                        ;
                        ;    www.corshamtech.com
                        ;
                        ; This was updated 06/13/2015 to be compliant with the
                        ; official specification, so the opcode values changed
                        ;
                        ; Another update on 09/04/2017
                        ;
                        ;=====================================================
                        ; Commands from host to Arduino
                        ;
0001 =                  PC_GET_VERSION	equ	$01
0005 =                  PC_PING		equ	$05	;ping Arduino
0006 =                  PC_LED_CONTROL	equ	$06	;LED control
0010 =                  PC_GET_DIR	equ	$10	;Get directory
0011 =                  PC_GET_MOUNTED	equ	$11	;Get mounted drive list
0012 =                  PC_MOUNT	equ	$12	;Mount drive
0013 =                  PC_UNMOUNT	equ	$13	;Unmount drive
0014 =                  PC_GET_STATUS	equ	$14	;Get status for one drive
0015 =                  PC_DONE		equ	$15	;Stop data
0015 =                  PC_ABORT	equ	PC_DONE
0016 =                  PC_READ_FILE	equ	$16	;Read regular file (non-DSK)
0017 =                  PC_READ_BYTES	equ	$17	;Read sequential bytes
0018 =                  PC_RD_SECTOR	equ	$18	;Read FLEX sector
0019 =                  PC_WR_SECTOR	equ	$19	;Write FLEX sector
001a =                  PC_GET_MAX	equ	$1a	;Get maximum drives
001b =                  PC_WRITE_FILE   equ	$1b	;Open file for writing
001c =                  PC_WRITE_BYTES	equ	$1c	;Data to be written
001d =                  PC_SAVE_CONFIG	equ	$1d	;Save SD.CFG with current value
001e =                  PC_SET_TIMER	equ	$1e	;Set RTC timer
001f =                  PC_WR_SEC_LONG	equ	$1f	;Write sector with long sec num
0020 =                  PC_RD_SEC_LONG	equ	$20	;Read sector with long sec num
                        ;
                        ;=====================================================
                        ; Responses from Arduino to host
                        ;
0081 =                  PR_VERSION_INFO	equ	$81	;Contains version information
0082 =                  PR_ACK		equ	$82	;ACK (no additional information)
0083 =                  PR_NAK		equ	$83	;NAK - one status byte follows
0085 =                  PR_PONG		equ	$85	;Reply to a ping
0090 =                  PR_DIR_ENTRY	equ	$90	;Directory entry
0091 =                  PR_DIR_END	equ	$91	;End of directory entries
0092 =                  PR_FILE_DATA	equ	$92	;File data
0093 =                  PR_STATUS	equ	$93	;Drive status
0094 =                  PR_SECTOR_DATA	equ	$94	;Sector data
0095 =                  PR_MOUNT_INFO	equ	$95	;Mount entry
0096 =                  PR_MAX_DRIVES	equ	$96	;Maximum number of drives
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; Error codes for NAK events.  Yes, these are in
                        ; decimal due to an error in the original
                        ; documentation.
                        ;
0000 =                  ERR_NONE	equ	0
000a =                  ERR_NOT_MOUNTED	equ	10
000b =                  ERR_MOUNTED	equ	11
000c =                  ERR_NOT_FOUND	equ	12
000d =                  ERR_READ_ONLY	equ	13
000e =                  ERR_BAD_DRIVE	equ	14
000f =                  ERR_BAD_TRACK	equ	15
0010 =                  ERR_BAD_SECTOR	equ	16
0011 =                  ERR_READ_ERROR	equ	17
0012 =                  ERR_WRITE_ERROR	equ	18
0013 =                  ERR_NOT_PRESENT	equ	19
0014 =                  ERR_NOT_IMPL	equ	20	;Command not implemented
                        
                        
                        		include	"pario.asm"
                        
                        ;CTMON65 version using a 6821
                        
                        ;*****************************************************
                        ; These are the low-level I/O routines to talk to the
                        ; Arduino processor connected to the KIM's I/O port.
                        ;
                        ; August 2014, Bob Applegate K2UT, bob@corshamtech.com
                        ;
                        ; Which port bits are used for what:
                        ;
                        ; A0 = Data 0, alternates input/output
                        ; A1 = Data 1, alternates input/output
                        ; A2 = Data 2, alternates input/output
                        ; A3 = Data 3, alternates input/output
                        ; A4 = Data 4, alternates input/output
                        ; A5 = Data 5, alternates input/output
                        ; A6 = Data 6, alternates input/output
                        ; A7 = Data 7, alternates input/output
                        ;
                        ; B0 = Direction bit, always output
                        ; B1 = Write strobe or ACK, always output
                        ; B2 = Read stroke or ACK, always input
                        ;
                        ;----------------------------------------------------
                        ; Bits in the B register
                        ;
0001 =                  DIRECTION	equ	%00000001
0002 =                  PSTROBE		equ	%00000010
0004 =                  ACK		equ	%00000100
                        ;
                        ;----------------------------------------------------
                        ; Which slot the parallel board is in.  This needs to
                        ; be set for the system in use.  As long as the user
                        ; programs only call functions in here, no other
                        ; file/application should know which slot the board
                        ; is in.
                        ;
0006 =                  PIASLOT		equ	6
                        ;
                        ; Computed addresses of 6821 registers
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- ctmon65.asm ---------------------------------

                        ;
e060 =                  PIABASE		equ	IO_BASE+(PIASLOT*IO_SIZE)
e060 =                  PIAREGA		equ	PIABASE		;data reg A
e060 =                  PIADDRA		equ	PIABASE		;data dir reg A
e061 =                  PIACTLA		equ	PIABASE+1	;control reg A
e062 =                  PIAREGB		equ	PIABASE+2	;data reg B
e062 =                  PIADDRB		equ	PIABASE+2	;data dir reg B
e063 =                  PIACTLB		equ	PIABASE+3	;control reg B
                        		code
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;*****************************************************
                        ; This is the initialization function.  Call before
                        ; doing anything else with the parallel port.
                        ;
fb1b :                  xParInit
                        ;
                        ; Set up the data direction register for port B so tha
                        ; the DIRECTION and PSTROBE bits are output.
                        ;
fb1b : a900             		lda	#0	;select DDR
fb1d : 8d63e0           		sta	PIACTLB	;...for port B
fb20 : a903             		lda	#DIRECTION | PSTROBE
fb22 : 8d62e0           		sta	PIADDRB
fb25 : a904             		lda	#4	;select data reg
fb27 : 8d63e0           		sta	PIACTLB
                        ;
                        ; Fall through to set up for writes...
                        ;
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- ctmon65.asm ---------------------------------

                        ;*****************************************************
                        ; This sets up for writing to the Arduino.  Sets up
                        ; direction registers, drives the direction bit, etc.
                        ;
fb2a : a900             xParSetWrite	lda	#0	;select DDR
fb2c : 8d61e0           		sta	PIACTLA	;...for port A
fb2f : a9ff             		lda	#$ff	;set bits for output
fb31 : 8d60e0           		sta	PIADDRA
fb34 : a904             		lda	#4	;select data reg
fb36 : 8d61e0           		sta	PIACTLA
                        ;
                        ; Set direction flag to output, clear ACK bit
                        ;
fb39 : a901             		lda	#DIRECTION
fb3b : 8d62e0           		sta	PIAREGB
fb3e : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- ctmon65.asm ---------------------------------

                        ;*****************************************************
                        ; This sets up for reading from the Arduino.  Sets up
                        ; direction registers, clears the direction bit, etc.
                        ;
fb3f : a900             xParSetRead	lda	#0	;select DDR
fb41 : 8d61e0           		sta	PIACTLA	;...for port A
fb44 : a900             		lda	#$00	;set bits for input
fb46 : 8d60e0           		sta	PIADDRA
fb49 : a904             		lda	#4	;select data reg
fb4b : 8d61e0           		sta	PIACTLA
                        ;
                        ; Set direction flag to input, clear ACK bit
                        ;
fb4e : a900             		lda	#0
fb50 : 8d62e0           		sta	PIAREGB
fb53 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- ctmon65.asm ---------------------------------

                        ;*****************************************************
                        ; This writes a single byte to the Arduino.  On entry,
                        ; the byte to write is in A.  This assumes ParSetWrite
                        ; was already called.
                        ;
                        ; Destroys A, all other registers preserved.
                        ;
                        ; Write cycle:
                        ;
                        ;    1. Wait for other side to lower ACK.
                        ;    2. Put data onto the bus.
                        ;    3. Set DIRECTION and PSTROBE to indicate data
                        ;       is valid and ready to read.
                        ;    4. Wait for ACK line to go high, indicating the
                        ;       other side has read the data.
                        ;    5. Lower PSTROBE.
                        ;    6. Wait for ACK to go low, indicating end of
                        ;       transfer.
                        ;
fb54 : 48               xParWriteByte	pha		;save data
fb55 : ad62e0           Parwl22		lda	PIAREGB	;check status
fb58 : 2904             		and	#ACK
fb5a : d0f9             		bne	Parwl22	;wait for ACK to go low
                        ;
                        ; Now put the data onto the bus
                        ;
fb5c : 68               		pla
fb5d : 8d60e0           		sta	PIAREGA
                        ;
                        ; Raise the strobe so the Arduino knows there is
                        ; new data.
                        ;
fb60 : ad62e0           		lda	PIAREGB
fb63 : 0902             		ora	#PSTROBE
fb65 : 8d62e0           		sta	PIAREGB
                        ;
                        ; Wait for ACK to go high, indicating the Arduino has
                        ; pulled the data and is ready for more.
                        ;
fb68 : ad62e0           Parwl33		lda	PIAREGB
fb6b : 2904             		and	#ACK
fb6d : f0f9             		beq	Parwl33
                        ;
                        ; Now lower the strobe, then wait for the Arduino to
                        ; lower ACK.
                        ;
fb6f : ad62e0           		lda	PIAREGB
fb72 : 29fd             		and	#~PSTROBE
fb74 : 8d62e0           		sta	PIAREGB
fb77 : ad62e0           Parwl44		lda	PIAREGB
fb7a : 2904             		and	#ACK
fb7c : d0f9             		bne	Parwl44
fb7e : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- ctmon65.asm ---------------------------------

                        ;*****************************************************
                        ; This reads a byte from the Arduino and returns it in
                        ; A.  Assumes ParSetRead was called before.
                        ;
                        ; This does not have a time-out.
                        ;
                        ; Preserves all other registers.
                        ;
                        ; Read cycle:
                        ;
                        ;    1. Wait for other side to raise ACK, indicating
                        ;       data is ready.
                        ;    2. Read data.
                        ;    3. Raise PSTROBE indicating data was read.
                        ;    4. Wait for ACK to go low.
                        ;    5. Lower PSTROBE.
                        ;
fb7f : ad62e0           xParReadByte	lda	PIAREGB
fb82 : 2904             		and	#ACK	;is their strobe high?
fb84 : f0f9             		beq	xParReadByte	;nope, no data
                        ;
                        ; Data is available, so grab and save it.
                        ;
fb86 : ad60e0           		lda	PIAREGA
fb89 : 48               		pha
                        ;
                        ; Now raise our strobe (their ACK), then wait for
                        ; them to lower their strobe.
                        ;
fb8a : ad62e0           		lda	PIAREGB
fb8d : 0902             		ora	#PSTROBE
fb8f : 8d62e0           		sta	PIAREGB
fb92 : ad62e0           Parrlp1		lda	PIAREGB
fb95 : 2904             		and	#ACK
fb97 : d0f9             		bne	Parrlp1	;still active
                        ;
                        ; Lower our ack, then were done.
                        ;
fb99 : ad62e0           		lda	PIAREGB
fb9c : 29fd             		and	#~PSTROBE
fb9e : 8d62e0           		sta	PIAREGB
fba1 : 68               		pla
fba2 : 60               		rts
                        
                        		include "diskfunc.asm"
                        		list
                        ;=====================================================
                        ; This is a collection of functions for performing
                        ; higher level disk functions.  This hides the nasty
                        ; details of communications with the remote disk
                        ; system.
                        ;
                        ; August 20, 2014 - Bob Applegate
                        ;                   bob@corshamtech.com
                        ;
                        ; 06/14/2015 - Bob Applegate
                        ;		Now that there is an official standard
                        ;		for the protocol between the host (this
                        ;		code) and the DCP (Arduino code), this
                        ;		code has been updated to be compliant.
                        ;
                        ; 01/14/2016 - Bob Applegate
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- ctmon65.asm ---------------------------------

                        ;              Finally converted to 6502.
                        ;
                        ;		include	"parproto.inc"
                        ;
                        ; Number of drives emulated
                        ;
0004 =                  DRIVES		equ	4
                        ;
                        ;=====================================================
                        ; This is a sanity check to verify connectivity to the
                        ; Arduino code is working.  Returns C clear if all is
                        ; good, or C set if not.
                        ;
fba3 : 202afb           DiskPing	jsr	xParSetWrite
fba6 : a905             		lda	#PC_PING	;command
fba8 : 2054fb           		jsr	xParWriteByte	;send to Arduino
fbab : 203ffb           		jsr	xParSetRead
fbae : 207ffb           		jsr	xParReadByte	;read their reply
fbb1 : 202afb           DiskRetGood	jsr	xParSetWrite
fbb4 : 18               		clc			;assume it's good
fbb5 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- ctmon65.asm ---------------------------------

                        ;=====================================================
                        ; This starts a directory read of the raw drive, not
                        ; the mounted drive.  No input parameters.  This simpl
                        ; sets up for reading the entries, then the user must
                        ; read each entry.
                        ;
                        ; Returns with C clear on success.  If error, C is set
                        ; and A contains the error code.
                        ;
fbb6 : 202afb           DiskDir		jsr	xParSetWrite
fbb9 : a910             		lda	#PC_GET_DIR	;send command
fbbb : 2054fb           		jsr	xParWriteByte
fbbe : 18               		clc		;assume it works
fbbf : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- ctmon65.asm ---------------------------------

                        ;=====================================================
                        ; Read the next directory entry.  On input, X (MSB)
                        ; and Y (LSB) point to a 13 byte area to receive the
                        ; drive data.
                        ;
                        ; Returns C set if end of directory (ie, attempt to
                        ; read and there are none left).  Else, C is clear
                        ; and X/Y point to the null at end of filename.
                        ;
fbc0 : 86f1             DiskDirNext	stx	sptr+1
fbc2 : 84f0             		sty	sptr
fbc4 : 203ffb           		jsr	xParSetRead	;read results
fbc7 : 207ffb           		jsr	xParReadByte	;get response code
fbca : c983             		cmp	#PR_NAK		;error?
fbcc : f01e             		beq	DDNErr
fbce : c991             		cmp	#PR_DIR_END	;end?
fbd0 : f01a             		beq	DDNErr
                        ;
                        ; This contains a directory entry.
                        ;
fbd2 : a000             		ldy	#0
fbd4 : 207ffb           DDNloop		jsr	xParReadByte
fbd7 : 91f0             		sta	(sptr),y
fbd9 : c900             		cmp	#0	;end?
fbdb : f006             		beq	DDNEnd
fbdd : 2002f9           		jsr	INCPT
fbe0 : 4cd4fb           		jmp	DDNloop
fbe3 : 202afb           DDNEnd		jsr	xParSetWrite
fbe6 : a6f1             		ldx	sptr+1
fbe8 : a4f0             		ldy	sptr
fbea : 18               		clc		;not end of files
fbeb : 60               		rts
                        ;
                        ; Error.  Set C and return.  This is not really
                        ; proper, since this implies a simple end of the
                        ; directory rather than an error.
                        ;
fbec : 202afb           DDNErr		jsr	xParSetWrite
fbef : 38               		sec
fbf0 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- ctmon65.asm ---------------------------------

                        ;=====================================================
                        ; This opens a file on the SD for reading.  On entry,
                        ; X (MSB) and Y (LSB) point to a null-terminated
                        ; filename to open.  On return, C is clear if the file
                        ; is open, or C set if an error (usually means the
                        ; file does not exist.
                        ;
                        ; Assumes write mode has been set.  Returns with it se
                        ;
fbf1 : a916             DiskOpenRead	lda	#PC_READ_FILE
fbf3 : 84f2             DiskOpen	sty	INL	;save ptr to filename
fbf5 : 86f3             		stx	INH
fbf7 : 48               		pha
fbf8 : 202afb           		jsr	xParSetWrite
fbfb : 68               		pla
fbfc : 2054fb           		jsr	xParWriteByte
fbff : a0ff             		ldy	#-1
fc01 : c8               DiskOpenLoop	iny
fc02 : b1f2             		lda	(INL),y
fc04 : 2054fb           		jsr	xParWriteByte
fc07 : b1f2             		lda	(INL),y
fc09 : d0f6             		bne	DiskOpenLoop
fc0b : 203ffb           		jsr	xParSetRead
fc0e : 207ffb           		jsr	xParReadByte	;get response
fc11 : c982             		cmp	#PR_ACK
fc13 : d005             		bne	DiskOpenErr
fc15 : 202afb           		jsr	xParSetWrite	;back to write mode
fc18 : 18               		clc
fc19 : 60               		rts
                        ;
                        ; Got an error.
                        ;
fc1a : 207ffb           DiskOpenErr	jsr	xParReadByte	;get error code
fc1d : 202afb           		jsr	xParSetWrite	;back to write mode
fc20 : 38               		sec
fc21 : 60               		rts
                        ;=====================================================
                        ; This opens a file on the SD for writing.  On entry,
                        ; X (MSB) and Y (LSB) point to a null-terminated
                        ; filename to open.  On return, C is clear if the file
                        ; is open, or C set if an error.
                        ;
                        ; Assumes write mode has been set.  Returns with it se
                        ;
fc22 : a91b             DiskOpenWrite	lda	#PC_WRITE_FILE
fc24 : 4cf3fb           		jmp	DiskOpen	;jump into common code
                        ;
                        ;=====================================================
                        ; On entry, A contains the number of bytes to read
                        ; from the file, X (MSB) and Y (LSB) point to the
                        ; buffer where to put the data.  On return, C will
                        ; be set if EOF was reached (and no data read), or
                        ; C will be clear and A contains the number of bytes
                        ; actually read into the buffer.
                        ;
                        ; Modifies A, X and Y.  Also modifies INL and INH
                        ; (00F8 and 00F9).
                        ;
fc27 : 48               DiskRead	pha
fc28 : 84f2             		sty	INL	;save ptr to buffer
fc2a : 86f3             		stx	INH
fc2c : a917             		lda	#PC_READ_BYTES
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- ctmon65.asm ---------------------------------

fc2e : 2054fb           		jsr	xParWriteByte	;command
fc31 : 68               		pla		;number of bytes to get
fc32 : 2054fb           		jsr	xParWriteByte
fc35 : 203ffb           		jsr	xParSetRead	;get ready for response
fc38 : 207ffb           		jsr	xParReadByte	;assume PR_FILE_DATA
fc3b : 207ffb           		jsr	xParReadByte	;length
fc3e : 48               		pha
fc3f : aa               		tax			;count
fc40 : f011             		beq	DiskReadEof	;zero = EOF
fc42 : a000             		ldy	#0	;offset
fc44 : 207ffb           DiskReadLoop	jsr	xParReadByte
fc47 : 91f2             		sta	(INL),y
fc49 : c8               		iny		;next offset
fc4a : ca               		dex
fc4b : d0f7             		bne	DiskReadLoop
fc4d : 202afb           		jsr	xParSetWrite
fc50 : 68               		pla		;retrieve byte count
fc51 : 18               DiskOk		clc	
fc52 : 60               		rts
fc53 : 202afb           DiskReadEof	jsr	xParSetWrite
fc56 : 68               		pla
fc57 : 38               		sec
fc58 : 60               		rts
                        ;
                        ;=====================================================
                        ; On entry, A contains the number of bytes to write
                        ; to the file, X (MSB) and Y (LSB) point to the
                        ; buffer where to get the data.  On return, C will
                        ; be set if an error was detected, or C will be clear
                        ; if no error.  Note that if A contains 0 on entry,
                        ; no bytes are written.
                        ;
                        ; Modifies A, X and Y.  Also modifies INL and INH
                        ; (00F8 and 00F9).
                        ;
fc59 : c900             DiskWrite	cmp	#0
fc5b : f0f4             		beq	DiskOk
fc5d : 84f2             		sty	INL	;save ptr to filename
fc5f : 86f3             		stx	INH
fc61 : 48               		pha
fc62 : a91c             		lda	#PC_WRITE_BYTES
fc64 : 2054fb           		jsr	xParWriteByte	;command
fc67 : 68               		pla		;number of bytes to write
fc68 : 48               		pha		;save again
fc69 : 2054fb           		jsr	xParWriteByte
fc6c : 68               		pla
fc6d : aa               		tax			;count
fc6e : a000             		ldy	#0	;offset
fc70 : b1f2             DiskWriteLoop	lda	(INL),y	;get next byte
fc72 : 2054fb           		jsr	xParWriteByte
fc75 : c8               		iny		;next offset
fc76 : ca               		dex
fc77 : d0f7             		bne	DiskWriteLoop
fc79 : 203ffb           		jsr	xParSetRead ;read the status
fc7c : 207ffb           		jsr	xParReadByte
fc7f : c982             		cmp	#PR_ACK
fc81 : f008             		beq	DiskOk1	;all good
fc83 : 207ffb           		jsr	xParReadByte	;read error code
fc86 : 202afb           		jsr	xParSetWrite 
fc89 : 38               		sec	
fc8a : 60               		rts
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- ctmon65.asm ---------------------------------

fc8b : 202afb           DiskOk1		jsr	xParSetWrite
fc8e : 18               		clc
fc8f : 60               		rts
                        ;
                        ;=====================================================
                        ; Call this to close any open file.  No parameters
                        ; and no return status.
                        ;
fc90 : a915             DiskClose	lda	#PC_DONE
fc92 : 4c54fb           		jmp	xParWriteByte
                        
                        
                        
                        	endif
                        ;
                        ;*****************************************************
                        ; Handlers for the interrupts.  Basiclly just jump 
                        ; through the vectors and hope they are set up properl
                        ;
fc95 : 6c02df           HandleNMI	jmp	(NMIvec)
fc98 : 6c00df           HandleIRQ	jmp	(IRQvec)
                        ;
                        ;*****************************************************
                        ; Default handler.  Save the state of the machine for
                        ; debugging.  This is taken from the KIM monitor SAVE
                        ; routine.
                        ;
fc9b :                  DefaultNMI
fc9b : 8d8edf           DefaultIRQ	sta	SaveA
fc9e : 68               		pla
fc9f : 8d93df           		sta	SaveC
fca2 : 68               		pla
fca3 : 8d91df           		sta	SavePC
fca6 : 68               		pla
fca7 : 8d92df           		sta	SavePC+1
fcaa : 8c90df           		sty	SaveY
fcad : 8e8fdf           		stx	SaveX
fcb0 : ba               		tsx
fcb1 : 8e94df           		stx	SaveSP
fcb4 : 206af6           		jsr	DumpRegisters
fcb7 : 20d6fa           		jsr	crlf
fcba : 4cb4f0           		jmp	WARM
                        ;
                        ;*****************************************************
                        ; 6502 vectors
                        ;
fffa =                  		org	$fffa
fffa : 95fc             		dw	HandleNMI
fffc : 45f0             		dw	RESET
fffe : 98fc             		dw	HandleIRQ
                        
                        
No errors in pass 2.
Wrote binary from address $e000 through $ffff.
Total size 8192 bytes.
