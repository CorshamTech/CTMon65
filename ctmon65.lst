AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- ctmon65.asm ---------------------------------

2422 lines read, no errors in pass 1.
                        ;*****************************************************
                        ; CTMON65
                        ;
                        ; This is the monitor for the Corsham Techologies, LLC
                        ; SS-50 65C02 board.  It's a fairly generic monitor th
                        ; can be ported to other 6502 based systems.
                        ;
                        ; Written mostly while on a family vacation in 2018, b
                        ; ideas and code were taken from other Corsham Tech
                        ; projects and various web pages (credit given in the
                        ; code).
                        ;
                        ; Bob Applegate
                        ; bob@corshamtech.com
                        ; www.corshamtech.com
                        ;*****************************************************
                        
                        ;=====================================================
                        ;-----------------------------------------------------
                        
                        		include	"config.inc"
                        ;*****************************************************
                        ; FILE: config.inc
                        ;
                        ; General configuration file
                        ;*****************************************************
                        ;
                        ; Current version and revision
                        ;
                        ;VERSION		equ	0
                        ;REVISION	equ	1
                        ;
0000 =                  FALSE		equ	0
0001 =                  TRUE		equ	!FALSE
                        ;
                        ; SS-50 bus constants
                        ;
e000 =                  IO_BASE		equ	$e000
0010 =                  IO_SIZE		equ	16
                        ;
                        ; Memory usage
                        ;
00f0 =                  ZERO_PAGE_START	equ	$00f0
f000 =                  ROM_START	equ	$f000
df00 =                  RAM_START	equ	$df00
                        ;
                        ; If enabled, turn on buffered input code.
                        ;
0000 =                  BUFFERED_INPUT	equ	FALSE
                        ;
0005 =                  MAX_ARGC	equ	5
                        ;
                        ; If enabled, the debugger will display the flag regis
                        ; in ASCII.  Nice, but takes more code.
                        ;
0001 =                  FULL_STATUS	equ	TRUE
                        ;
                        ; Enable EXTENDED_CMDS to allow linking external comma
                        ; to the command handler.
                        ;
0000 =                  EXTENDED_CMDS	equ	FALSE
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ; Define to enable SD related functions
                        ;
0001 =                  SD_ENABLED	equ	TRUE
                        ;
                        ; Size of the keyboard buffer
                        ;
0084 =                  BUFFER_SIZE	equ	132
                        
                        
                        ;
                        ; Version and revision
                        ;
0000 =                  VERSION		equ	0
0002 =                  REVISION	equ	2
                        ;
                        ;-----------------------------------------------------
                        ; ASCII constants
                        ;
0007 =                  BELL		equ	$07
0008 =                  BS		equ	$08
000a =                  LF		equ	$0a
000d =                  CR		equ	$0d
                        ;
                        ; Max number of bytes per line for hex dump
                        ;
0010 =                  BYTESLINE	equ	16
                        ;
                        ; These are various buffer sizes
                        ;
000c =                  FILENAME_SIZE	equ	12
                        ;
                        ; Intel HEX record types
                        ;
0000 =                  DATA_RECORD	equ	$00
0001 =                  EOF_RECORD	equ	$01
                        ;
                        ; Zero-page data
                        ;
                        ;		zpage
                        		bss
00f0 =                  		org	ZERO_PAGE_START
00f0 =                  sptr		ds	2
00f2 =                  INL		ds	1
00f3 =                  INH		ds	1
00f4 =                  putsp		ds	2
                        ;
                        ; Non zero-page data
                        ;
                        		bss
df00 =                  		org	RAM_START
                        ;
                        ; The use of memory starting from here will remain
                        ; constant through different versions of CTMON65.
                        ;
df00 =                  IRQvec		ds	2
df02 =                  NMIvec		ds	2
                        ;
                        ; Before a L(oad) command, these are set to $FF.
                        ; After loading, if they are different, jump to
                        ; that address.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- ctmon65.asm ---------------------------------

df04 =                  AutoRun		ds	2
                        ;
                        ; Pointer to the subroutine that gets the next input
                        ; character.  Used for doing disk/console input.
                        ;
df06 =                  inputVector	ds	2
                        ;
                        ; Same thing for output.
                        ;
df08 =                  outputVector	ds	2
                        ;
                        ; Buffer for GETLINE
                        ;
df0a =                  buffer		ds	BUFFER_SIZE
                        ;
                        ; Anything from here can be moved between versions.
                        ;
df8e =                  SaveA		ds	1
df8f =                  SaveX		ds	1
df90 =                  SaveY		ds	1
df91 =                  SavePC		ds	2
df93 =                  SaveC		ds	1
df94 =                  SaveSP		ds	1
df95 =                  SAL		ds	1
df96 =                  SAH		ds	1
df97 =                  EAL		ds	1
df98 =                  EAH		ds	1
df99 =                  tempA		ds	1
df9a =                  filename	ds	FILENAME_SIZE+1
dfa7 =                  diskBufOffset	ds	1
dfa8 =                  diskBufLength	ds	1
dfa9 =                  CHKL		ds	1
dfaa =                  ID		ds	1
dfab =                  Temp16L		ds	1
dfac =                  Temp16H		ds	1
                        ;
                        ; This weird bit of DBs is to allow for the fact that
                        ; I'm putting a 4K monitor into the top half of an
                        ; 8K EEPROM.  This forces the actual code to the top
                        ; 4K section.
                        ;
                        		code
e000 =                  		org	ROM_START-$1000
e000 : 54686973207370.. 		db	"This space for rent.",CR,LF
e016 : 41637475616c6c.. 		db	"Actually, this just forces the "
e035 : 62696e61727920.. 		db	"binary file to be 8K long."
                        ;
f000 =                  		org	ROM_START
                        ;
                        ;=====================================================
                        ; Jump table to common functions.  The entries in this
                        ; table are used by external programs, so nothing can 
                        ; moved or removed from this table.  New entries alway
                        ; go at the end.  Many of these are internal functions
                        ; and I figured they might be handy for others.
                        ;
f000 : 4c45f0           COLDvec		jmp	RESET
f003 : 4cb4f0           WARMvec		jmp	WARM
                        ;
                        ; These are the major and minor revision numbers so th
                        ; code can check to see which CTMON65 version is runni
                        ;
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- ctmon65.asm ---------------------------------

f006 : 00               CTMON65ver	db	VERSION
f007 : 02               CTMON65rev	db	REVISION
f008 : 00               		db	0
                        ;
                        ; Console related functions
                        ;
f009 : 4c3bfb           CINvec		jmp	cin
f00c : 4c2efb           COUTvec		jmp	cout
f00f : 4c46fb           CSTATvec	jmp	cstatus
f012 : 4c91fa           PUTSILvec	jmp	putsil
f015 : 4ccffa           GETLINEvec	jmp	getline
f018 : 4c07fb           CRLFvec		jmp	crlf
f01b : 4ceafa           OUTHEXvec	jmp	HexA
                        ;
                        ; Low-level functions to access the SD card system
                        ;
                        	if	SD_ENABLED
f01e : 4c4cfb           XPARINITvev	jmp	xParInit
f021 : 4c5bfb           XPARSETWRITEvec	jmp	xParSetWrite
f024 : 4c70fb           XPARSETREADvec	jmp	xParSetRead
f027 : 4c85fb           XPARWRITEvec	jmp	xParWriteByte
f02a : 4cb0fb           XPARREADvec	jmp	xParReadByte
                        ;
                        ; Higher level SD card functions
                        ;
f02d : 4cd4fb           DISKPINGvec	jmp	DiskPing
f030 : 4ce7fb           DISKDIRvec	jmp	DiskDir
f033 : 4cf1fb           DISKDIRNEXTVEC	jmp	DiskDirNext
f036 : 4c22fc           DISKOPENREADvec	jmp	DiskOpenRead
f039 : 4c53fc           DISKOPENWRITvec	jmp	DiskOpenWrite
f03c : 4c58fc           DISKREADvec	jmp	DiskRead
f03f : 4c8afc           DISKWRITEvec	jmp	DiskWrite
f042 : 4cc1fc           DISKCLOSEvec	jmp	DiskClose
                        	endif	;SD_ENABLED
                        ;
                        ;-----------------------------------------------------
                        ; Cold start entry point
                        ;
f045 : a2ff             RESET		ldx	#$ff
f047 : 9a               		txs
f048 : 2022fb           		jsr	cinit
f04b : 204cfb           		jsr	xParInit
                        ;
                        ; Reset the NMI and IRQ vectors
                        ;
f04e : a9cc             		lda	#DefaultNMI&$ff
f050 : 8d02df           		sta	NMIvec
f053 : a9fc             		lda	#DefaultNMI>>8
f055 : 8d03df           		sta	NMIvec+1
                        ;
f058 : a9cc             		lda	#DefaultIRQ&$ff
f05a : 8d00df           		sta	IRQvec
f05d : a9fc             		lda	#DefaultIRQ>>8
f05f : 8d01df           		sta	IRQvec+1
                        ;
                        ; Print start-up message
                        ;
f062 : 2091fa           		jsr	putsil
f065 : 0d0a0a0a0a       		db	CR,LF,LF,LF,LF
f06a : 43544d4f4e3635.. 		db	"CTMON65 rev "
f076 : 302e             		db	VERSION+'0','.'
f078 : 32               		db	REVISION+'0'
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- ctmon65.asm ---------------------------------

f079 : 0d0a             		db	CR,LF
f07b : 30392f32302f32.. 		db	"09/20/2018 by Bob Applegate K2UT"
f09b : 2c20626f624063.. 		db	", bob@corshamtech.com"
f0b0 : 0d0a0a00         		db	CR,LF,LF,0
                        ;
                        ;-----------------------------------------------------
                        ; Warm start entry point.  This is the best place to j
                        ; in the code after a user program has ended.  Go thro
                        ; the vector, of course!
                        ;
f0b4 : a2ff             WARM		ldx	#$ff
f0b6 : 9a               		txs
                        ;
                        ; Prompt the user and get a line of text
                        ;
f0b7 : 20b4f9           prompt		jsr	setOutputConsole
f0ba : 20cff9           		jsr	setInputConsole
f0bd : 2091fa           		jsr	putsil
f0c0 : 0d0a             		db	CR,LF
f0c2 : 43544d4f4e3635.. 		db	"CTMON65> "
f0cb : 00               		db	0
f0cc : 203bfb           prompt2		jsr	cin
f0cf : c90d             		cmp	#CR
f0d1 : f0e4             		beq	prompt
f0d3 : c90a             		cmp	#LF
f0d5 : f0f5             		beq	prompt2	;don't prompt
f0d7 : 8d99df           		sta	tempA
                        ;
                        ; Now cycle through the list of commands looking for
                        ; what the user just pressed.
                        ;
f0da : a9f3             		lda	#commandTable&$ff
f0dc : 85f0             		sta	sptr
f0de : a9f0             		lda	#commandTable/256
f0e0 : 85f1             		sta	sptr+1
f0e2 : 2074f2           		jsr	searchCmd	;try to find it
                        ;
                        ; Hmmm... wasn't one of the built in commands, so
                        ; see if it's an extended command.
                        ;
                        	if	EXTENDED_CMDS
                        		lda	ExtensionAddr
                        		sta	sptr
                        		lda	ExtensionAddr+1
                        		sta	sptr+1
                        		jsr	searchCmd	;try to find it
                        	endif
                        ;
                        ; If that returns, then the command was not found.
                        ; Print that it's unknown.
                        ;
f0e5 : 2091fa           		jsr	putsil
f0e8 : 202d204875683f00 		db	" - Huh?",0
f0f0 : 4cb7f0           cmdFound	jmp	prompt
                        ;
                        ;=====================================================
                        ; Vector table of commands.  Each entry consists of a
                        ; single ASCII character (the command), a pointer to
                        ; the function which handles the command, and a pointe
                        ; to a string that describes the command.
                        ;
f0f3 : 3f               commandTable	db	'?'
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- ctmon65.asm ---------------------------------

f0f4 : c7f7             		dw	showHelp
f0f6 : 2bf1             		dw	quesDesc
                        ;
f0f8 : 43               		db	'C'
f0f9 : 30f7             		dw	doContinue
f0fb : 48f1             		dw	cDesc
                        ;
f0fd : 44               		db	'D'
f0fe : 5af9             		dw	doDiskDir
f100 : 69f1             		dw	dDesc
                        ;
f102 : 45               		db	'E'	;edit memory
f103 : 72f3             		dw	editMemory
f105 : 86f1             		dw	eDesc
                        ;
f107 : 48               		db	'H'	;hex dump
f108 : b2f2             		dw	hexDump
f10a : a0f1             		dw	hDesc
                        ;
f10c : 4a               		db	'J'	;jump to address
f10d : 98f2             		dw	jumpAddress
f10f : bef1             		dw	jDesc
                        ;
f111 : 4c               		db	'L'	;load Intel HEX file
f112 : d3f3             		dw	loadHex
f114 : dcf1             		dw	lDesc
                        ;
f116 : 4d               		db	'M'	;perform memory test
f117 : 1af8             		dw	memTest
f119 : f8f1             		dw	mDesc
                        ;
f11b : 50               		db	'P'	;ping remote disk
f11c : 3af9             		dw	pingDisk
f11e : 12f2             		dw	pDesc
                        ;
f120 : 53               		db	'S'	;save memory as hex file
f121 : 19f5             		dw	saveHex
f123 : 35f2             		dw	sDesc
                        ;
f125 : 54               		db	'T'	;type a file on SD
f126 : 28fa             		dw	typeFile
f128 : 57f2             		dw	tDesc
                        ;
f12a : 00               		db	0	;marks end of table
                        ;
                        ;=====================================================
                        ; Descriptions for each command in the command table.
                        ; This wastes a lot of space... I'm open for any
                        ; suggestions to keep the commands clear but reducing
                        ; the amount of space this table consumes.
                        ;
f12b : 3f202e2e2e2e2e.. quesDesc	db	"? ........... Show this help",0
f148 : 43202e2e2e2e2e.. cDesc		db	"C ........... Continue execution",0
f169 : 44202e2e2e2e2e.. dDesc		db	"D ........... Disk directory",0
f186 : 45207878787820.. eDesc		db	"E xxxx ...... Edit memory",0
f1a0 : 48207878787820.. hDesc		db	"H xxxx xxxx . Hex dump memory",0
f1be : 4a207878787820.. jDesc		db	"J xxxx ...... Jump to address",0
f1dc : 4c202e2e2e2e2e.. lDesc		db	"L ........... Load HEX file",0
f1f8 : 4d207878787820.. mDesc		db	"M xxxx xxxx . Memory test",0
f212 : 50202e2e2e2e2e.. pDesc		db	"P ........... Ping disk controller",0
f235 : 53207878787820.. sDesc		db	"S xxxx xxxx . Save memory to file",0
f257 : 54202e2e2e2e2e.. tDesc		db	"T ........... Type disk file",0
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; This subroutine will search for a command in a table
                        ; and call the appropriate handler.  See the command
                        ; table near the start of the code for what the format
                        ; is.  If a match is found, pop off the return address
                        ; from the stack and jump to the code.  Else, return.
                        ;
f274 : a000             searchCmd	ldy	#0
f276 : b1f0             cmdLoop		lda	(sptr),y
f278 : f01d             		beq	cmdNotFound
f27a : cd99df           		cmp	tempA	;compare to user's input
f27d : f007             		beq	cmdMatch
f27f : c8               		iny		;start of function ptr
f280 : c8               		iny
f281 : c8               		iny		;start of help
f282 : c8               		iny
f283 : c8               		iny		;move to next command
f284 : d0f0             		bne	cmdLoop
                        ;
                        ; It's found!  Load up the address of the code to call
                        ; pop the return address off the stack and jump to the
                        ; handler.
                        ;
f286 : c8               cmdMatch	iny
f287 : b1f0             		lda	(sptr),y	;handler LSB
f289 : 48               		pha
f28a : c8               		iny
f28b : b1f0             		lda	(sptr),y	;handler MSB
f28d : 85f1             		sta	sptr+1
f28f : 68               		pla
f290 : 85f0             		sta	sptr
f292 : 68               		pla		;pop return address
f293 : 68               		pla
f294 : 6cf000           		jmp	(sptr)
                        ;
                        ; Not found, so just return.
                        ;
f297 : 60               cmdNotFound	rts
                        ;
                        ;=====================================================
                        ; Handles the command to prompt for an address and the
                        ; jump to it.
                        ;
f298 : 2091fa           jumpAddress	jsr	putsil
f29b : 4a756d7020746f.. 		db	"Jump to ",0
f2a4 : 2084f7           		jsr	getStartAddr
f2a7 : b006             		bcs	cmdRet	;branch on bad address
f2a9 : 2007fb           		jsr	crlf
f2ac : 6c95df           		jmp	(SAL)	;else jump to address
                        ;
f2af : 4cb7f0           cmdRet		jmp	prompt
                        ;
                        ;=====================================================
                        ; Do a hex dump of a region of memory.  This code was
                        ; taken from MICRO issue 5, from an article by
                        ; J.C. Williams.  I changed it a bit, but it's still
                        ; basically the same code.
                        ;
                        ; Slight bug: the starting address is rounded down to
                        ; a multiple of 16.  I'll fix it eventually.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- ctmon65.asm ---------------------------------

f2b2 : 2091fa           hexDump		jsr	putsil
f2b5 : 4865782064756d.. 		db	"Hex dump ",0
f2bf : 20a8f7           		jsr	getAddrRange
f2c2 : b0eb             		bcs	cmdRet
f2c4 : 2091fa            jsr putsil
f2c7 : 4865726520410d..  db "Here A",CR,LF,0
f2d0 : 2007fb           		jsr	crlf
                        ;
                        ; Move start address to sptr but rounded down to the
                        ; 16 byte boundary.  While it's really cool to start a
                        ; the exact address specified by the user, it adds
                        ; code that really doesn't add much (any?) value.
                        ;
f2d3 : ad96df           		lda	SAH
f2d6 : 85f1             		sta	sptr+1
f2d8 : ad95df           		lda	SAL
f2db : 29f0             		and	#$f0	;force to 16 byte
f2dd : 85f0             		sta	sptr
f2df : 2091fa            jsr putsil
f2e2 : 4865726520420d..  db "Here B",CR,LF,0
                        ;
                        ;-----------------------------------------------------
                        ; This starts each line.  Set flag to indcate we're
                        ; doing the hex portion, print address, etc.
                        ;
f2eb : 2007fb           hexdump1	jsr	crlf
f2ee : a5f1             		lda	sptr+1
f2f0 : 20eafa           		jsr	HexA	;print the address
                        
f2f3 : 2091fa            jsr putsil
f2f6 : 4865726520430d..  db "Here C",CR,LF,0
f2ff : a5f0             		lda	sptr
f301 : 20eafa           		jsr	HexA
f304 : 2017fb           		jsr	space2	;two spaces after address
f307 : 2091fa            jsr putsil
f30a : 4865726520440d..  db "Here D",CR,LF,0
                        ;
                        ;-----------------------------------------------------
                        ; This loop gets the next byte, prints the value in
                        ; hex and adds the appropriate ASCII character to the
                        ; buffer.
                        ;
f313 : a000             		ldy	#0	;offset from sptr
f315 : a200             hexdump3	ldx	#0	;bytes on line
f317 : b1f0             hexdump2	lda	(sptr),y	;get byte
f319 : 20eafa           		jsr	HexA	;print hex version of it
f31c : 201afb           		jsr	space	;space before next value
                        ;
                        ; Put the byte into the buffer
                        ;
f31f : c920             		cmp	#' '
f321 : 9004             		bcc	hexdot
f323 : c97e             		cmp	#'~'
f325 : 9002             		bcc	hexpr
f327 : a92e             hexdot		lda	#'.'
f329 : 9d0adf           hexpr		sta	buffer,x	;save for later
                        ;
                        ; See if the end of the user defined area was just dum
                        ;
f32c : a5f0             hexdumpchk	lda	sptr
f32e : cd97df           		cmp	EAL
f331 : d007             		bne	hexdump4
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- ctmon65.asm ---------------------------------

f333 : a5f1             		lda	sptr+1
f335 : cd98df           		cmp	EAH
f338 : f00e             		beq	hexdumpend
                        ;
                        ; Not done yet, so see if at end of the line
                        ;
f33a : 2033f9           hexdump4	jsr	INCPT	;move to next address
f33d : e8               		inx
f33e : e010             		cpx	#16
f340 : d0d5             		bne	hexdump2
                        ;
                        ; At end, so dump ASCII contents
                        ;
f342 : 2052f3           		jsr	dumpbuffer
f345 : 4cebf2           		jmp	hexdump1
                        ;
                        ; At the end but still need to dump the ASCII version.
                        ;
f348 : e8               hexdumpend	inx		;count last byte output
f349 : 2052f3           		jsr	dumpbuffer
f34c : 2007fb           		jsr	crlf
f34f : 4cb7f0           ret1		jmp	prompt
                        
                        
                        ;
                        ;=====================================================
f352 :                  dumpbuffer
                        
f352 : e010             hexdump90	cpx	#16
f354 : f00b             		beq	hexdump91
f356 : a920             		lda	#' '
f358 : 9d0adf           		sta	buffer,x
f35b : 2014fb           		jsr	space3
f35e : e8               		inx
f35f : d0f1             		bne	hexdump90
                        
                        
                        
f361 : 2014fb           hexdump91	jsr	space3	;separate the two passes
f364 : a200             		ldx	#0
f366 : bd0adf           hexdump99	lda	buffer,x
f369 : 202efb           		jsr	cout
f36c : e8               		inx
f36d : e010             		cpx	#16
f36f : d0f5             		bne	hexdump99
f371 : 60               		rts
                        ;
                        ;=====================================================
                        ; Edit memory.  This waits for a starting address to b
                        ; entered.  It will display the current address and it
                        ; contents.  Possible user inputs and actions:
                        ;
                        ;   Two hex digits will place that value in memory
                        ;   RETURN moves to next address
                        ;   BACKSPACE moves back one address
                        ;
f372 : 2091fa           editMemory	jsr	putsil
f375 : 45646974206d65.. 		db	"Edit memory ",0
f382 : 2084f7           		jsr	getStartAddr
f385 : b0c8             		bcs	ret1
f387 : ad95df           		lda	SAL	;move address into...
f38a : 85f0             		sta	sptr	;...POINT
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- ctmon65.asm ---------------------------------

f38c : ad96df           		lda	SAH
f38f : 85f1             		sta	sptr+1
                        ;
                        ; Display the current location
                        ;
f391 : 2007fb           editMem1	jsr	crlf
f394 : a5f1             		lda	sptr+1
f396 : 20eafa           		jsr	HexA
f399 : a5f0             		lda	sptr
f39b : 20eafa           		jsr	HexA
f39e : 201afb           		jsr	space
f3a1 : a000             		ldy	#0
f3a3 : b1f0             		lda	(sptr),y	;get byte
f3a5 : 20eafa           		jsr	HexA	;print it
f3a8 : 201afb           		jsr	space
                        ;
f3ab : 204af7           		jsr	getHex
f3ae : b00d             		bcs	editMem2	;not hex
f3b0 : a000             		ldy	#0
f3b2 : 91f0             		sta	(sptr),y	;save new value
                        ;
                        ; Bump POINT to next location
                        ;
f3b4 : e6f0             editMem3	inc	sptr
f3b6 : d0d9             		bne	editMem1
f3b8 : e6f1             		inc	sptr+1
f3ba : 4c91f3           		jmp	editMem1
                        ;
                        ; Not hex, so see if another command
                        ;
f3bd : c90d             editMem2	cmp	#CR
f3bf : f0f3             		beq	editMem3	;move to next
f3c1 : c908             		cmp	#BS
f3c3 : d08a             		bne     ret1		;else exit
                        ;
                        ; Move back one location
                        ;
f3c5 : 38               		sec
f3c6 : a5f0             		lda	sptr
f3c8 : e901             		sbc	#1
f3ca : 85f0             		sta	sptr
f3cc : b0c3             		bcs	editMem1
f3ce : c6f1             		dec	sptr+1
f3d0 : 4c91f3           		jmp	editMem1
                        ;
                        ;=====================================================
                        ; This handles the Load hex command.
                        ;
f3d3 : a9ff             loadHex		lda	#$ff
f3d5 : 8d05df           		sta	AutoRun+1
                        ;
f3d8 : 2091fa           		jsr	putsil
f3db : 0d0a             		db	CR,LF
f3dd : 456e7465722066.. 		db	"Enter filename, or Enter to "
f3f9 : 6c6f6164206672.. 		db	"load from console: ",0
                        ;
f40d : 2047f6           		jsr	getFileName	;get filename
f410 : ad9adf           		lda	filename	;null?
f413 : f02d             		beq	loadHexConsole	;load from console
                        ;
                        ; Open the file
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- ctmon65.asm ---------------------------------

f415 : a09a             		ldy	#filename&$ff
f417 : a2df             		ldx	#filename/256
f419 : 2022fc           		jsr	DiskOpenRead
f41c : 901e             		bcc	loadHexOk	;opened ok
                        ;
f41e : 2091fa           openfail	jsr	putsil
f421 : 0d0a             		db	CR,LF
f423 : 4661696c656420.. 		db	"Failed to open file"
f436 : 0d0a00           		db	CR,LF,0
f439 : 4cb7f0           cmdRet3		jmp	prompt
                        ;
f43c : 20e3f9           loadHexOk	jsr	setInputFile	;redirect input
f43f : 4c70f4           		jmp	loadStart
                        ;
                        ; They are loading from the console
                        ;
f442 : 2091fa           loadHexConsole	jsr	putsil
f445 : 0d0a             		db	CR,LF
f447 : 57616974696e67.. 		db	"Waiting for file, or ESC to"
f462 : 20657869742e2e2e 		db	" exit..."
f46a : 0d0a00           		db	CR,LF,0
f46d : 20cff9           		jsr	setInputConsole
                        ;
                        ; The start of a line.  First character should be a
                        ; colon, but toss out CRs, LFs, etc.  Anything else
                        ; causes an abort.
                        ;
f470 : 20f6f9           loadStart	jsr	redirectedGetch	;get start of line
f473 : c90d             		cmp	#CR
f475 : f0f9             		beq	loadStart
f477 : c90a             		cmp	#LF
f479 : f0f5             		beq	loadStart
f47b : c93a             		cmp	#':'	;what we expect
f47d : d034             		bne	loadAbort
                        ;
                        ; Get the header of the record
                        ;
f47f : a900             		lda	#0
f481 : 8da9df           		sta	CHKL	;initialize checksum
                        ;
f484 : 204af7           		jsr	getHex	;get byte count
f487 : b02a             		bcs	loadAbort
f489 : 8d8fdf           		sta	SaveX	;save byte count
f48c : 208df9           		jsr	updateCrc
f48f : 204af7           		jsr	getHex	;get the MSB of offset
f492 : b01f             		bcs	loadAbort
f494 : 85f1             		sta	sptr+1
f496 : 208df9           		jsr	updateCrc
f499 : 204af7           		jsr	getHex	;get LSB of offset
f49c : b015             		bcs	loadAbort
f49e : 85f0             		sta	sptr
f4a0 : 208df9           		jsr	updateCrc
f4a3 : 204af7           		jsr	getHex	;get the record type
f4a6 : b00b             		bcs	loadAbort
f4a8 : 208df9           		jsr	updateCrc
                        ;
                        ; Only handle two record types:
                        ;    00 = data record
                        ;    01 = end of file record
                        ;
f4ab : c900             		cmp	#DATA_RECORD
f4ad : f03a             		beq	loadDataRec
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- ctmon65.asm ---------------------------------

f4af : c901             		cmp	#EOF_RECORD
f4b1 : f016             		beq	loadEof
                        ;
                        ; Unknown record type
                        ;
f4b3 : 2091fa           loadAbort       jsr	putsil
f4b6 : 0d0a             		db	CR,LF
f4b8 : 41626f7274696e67 		db	"Aborting"
f4c0 : 0d0a00           		db	CR,LF,0
f4c3 : 20cff9           loadExit	jsr	setInputConsole
f4c6 : 4cb7f0           		jmp	prompt
                        ;
                        ; EOF is easy
                        ;
f4c9 : 204af7           loadEof		jsr	getHex	;get checksum
f4cc : 2091fa           		jsr	putsil
f4cf : 0d0a             		db	CR,LF
f4d1 : 5375636365737321 		db	"Success!"
f4d9 : 0d0a00           		db	CR,LF,0
                        ;
                        ; If the auto-run vector is no longer $ffff, then jump
                        ; to whatever it points to.
                        ;
f4dc : ad05df           		lda	AutoRun+1
f4df : c9ff             		cmp	#$ff		;unchanged?
f4e1 : f003             		beq	lExit1
f4e3 : 6c04df           		jmp	(AutoRun)	;execute!
                        ;
f4e6 : 4cc3f4           lExit1		jmp	loadExit
                        ;
                        ; Data records have more work.  After processing the
                        ; line, print a dot to indicate progress.  This should
                        ; be re-thought as it could slow down loading a really
                        ; big file if the console speed is slow.
                        ;
f4e9 : ae8fdf           loadDataRec	ldx	SaveX	;byte count
f4ec : a000             		ldy	#0	;offset
f4ee : 8e8fdf           loadData1	stx	SaveX
f4f1 : 8c90df           		sty	SaveY
f4f4 : 204af7           		jsr	getHex
f4f7 : b0ba             		bcs	loadAbort
f4f9 : 208df9           		jsr	updateCrc
f4fc : ac90df           		ldy	SaveY
f4ff : ae8fdf           		ldx	SaveX
f502 : 91f0             		sta	(sptr),y
f504 : c8               		iny
f505 : ca               		dex
f506 : d0e6             		bne	loadData1
                        ;
                        ; All the bytes were read so get the checksum and see
                        ; if it agrees.  The checksum is a twos-complement, so
                        ; just add the checksum into what we've been calculati
                        ; and if the result is zero then the record is good.
                        ;
f508 : 204af7           		jsr	getHex	;get checksum
f50b : 18               		clc
f50c : 6da9df           		adc	CHKL
f50f : d0a2             		bne	loadAbort	;non-zero is error
                        ;
f511 : a92e             		lda	#'.'	;sanity indicator when
f513 : 202efb           		jsr	cout	;...loading from file
f516 : 4c70f4           		jmp	loadStart
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; Handles the command to save a region of memory as a
                        ; file on the SD.
                        ;
f519 : 20a8f7           saveHex		jsr	getAddrRange	;get range to dump
f51c : b0c8             		bcs	lExit1	;abort on error
                        ;
                        ; Get the filename to save to
                        ;
f51e : 2091fa           		jsr	putsil
f521 : 0d0a             		db	CR,LF
f523 : 456e7465722066.. 		db	"Enter filename, or Enter to "
f53f : 6c6f6164206672.. 		db	"load from console: ",0
                        ;
f553 : 2047f6           		jsr	getFileName	;get filename
f556 : ad9adf           		lda	filename	;null?
f559 : f012             		beq	saveHexConsole	;dump to console
                        ;
                        ; They selected a file, so try to open it.
                        ;
f55b : a2df             		ldx	#filename>>8
f55d : a09a             		ldy	#filename&$ff
f55f : 2053fc           		jsr	DiskOpenWrite	;attempt to open file
f562 : 9003             		bcc	sopenok		;branch if opened ok
f564 : 4c1ef4           		jmp	openfail
                        ;
f567 : 20bff9           sopenok		jsr	setOutputFile
f56a : 4c70f5           		jmp	savehex2
                        ;
                        ; They are saving to the console.  Set up the output
                        ; vector and do the job.
                        ;
f56d : 20b4f9           saveHexConsole	jsr	setOutputConsole
                        ;
                        ; Compute the number of bytes to dump
                        ;
f570 : 38               savehex2	sec
f571 : ad97df           		lda	EAL
f574 : ed95df           		sbc	SAL
f577 : 8dabdf           		sta	Temp16L
f57a : ad98df           		lda	EAH
f57d : ed96df           		sbc	SAH
f580 : 8dacdf           		sta	Temp16H
f583 : 9042             		bcc	SDone	;start > end
f585 : 0500             		ora	0
f587 : 303e             		bmi	SDone	;more than 32K seems wrong
                        ;
                        ; Add one to the count
                        ;
f589 : eeabdf           		inc	Temp16L
f58c : d003             		bne	slab1
f58e : eeacdf           		inc	Temp16H
                        ;
                        ; Move pointer to zero page
                        ;
f591 : ad95df           slab1		lda	SAL
f594 : 85f0             		sta	sptr
f596 : ad96df           		lda	SAH
f599 : 85f1             		sta	sptr+1
                        ;
                        ; Top of each loop.  Start by seeing if there are any 
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- ctmon65.asm ---------------------------------

                        ; left to dump.
                        ;
f59b : adacdf           Sloop1		lda	Temp16H
f59e : d02a             		bne	Sgo	;more to do
f5a0 : adabdf           		lda	Temp16L
f5a3 : d025             		bne	Sgo	;more to do
                        ;
                        ; At end of the region, so output an end record.  This
                        ; probably looks like overkill but keep in mind this
                        ; might be going to a file so we can't use the normal
                        ; string put functions.
                        ;
f5a5 : a93a             		lda	#':'
f5a7 : 20b1f9           		jsr	redirectedOutch
f5aa : a900             		lda	#0
f5ac : 2097f9           		jsr	HexToOutput
f5af : 2097f9           		jsr	HexToOutput
f5b2 : 2097f9           		jsr	HexToOutput
f5b5 : a901             		lda	#1
f5b7 : 2097f9           		jsr	HexToOutput
f5ba : a9ff             		lda	#$ff
f5bc : 2097f9           		jsr	HexToOutput
                        ;
                        ; If output to file, flush and close the file.
                        ;
f5bf : ad9adf           		lda	filename
f5c2 : f003             		beq	SDone		;it's going to console
f5c4 : 2082fa           		jsr	CloseOutFile
f5c7 : 4cb7f0           SDone		jmp	prompt		;back to the monitor
                        ;
                        ; This dumps the next line.  See how many bytes are le
                        ; and if more than BYTESLINE, then just do BYTESLINE.
                        ;
f5ca : adacdf           Sgo		lda	Temp16H
f5cd : d007             		bne	Sdef	;do default number of bytes
f5cf : adabdf           		lda	Temp16L
f5d2 : c910             		cmp	#BYTESLINE
f5d4 : 9002             		bcc	Scnt	;more than max per line
f5d6 : a910             Sdef		lda	#BYTESLINE
f5d8 : 8d99df           Scnt		sta	tempA	;for decrementing
f5db : 8daadf           		sta	ID	;for subtracting
                        ;
                        ; Put out the header
                        ;
f5de : a93a             		lda	#':'
f5e0 : 20b1f9           		jsr	redirectedOutch
                        ;
f5e3 : ad99df           		lda	tempA
f5e6 : 8da9df           		sta	CHKL	;start checksum
f5e9 : 2097f9           		jsr	HexToOutput
                        ;
f5ec : a5f1             		lda	sptr+1	;starting address
f5ee : 208df9           		jsr	updateCrc
f5f1 : 2097f9           		jsr	HexToOutput
f5f4 : a5f0             		lda	sptr
f5f6 : 208df9           		jsr	updateCrc
f5f9 : 2097f9           		jsr	HexToOutput
                        ;
f5fc : a900             		lda	#0	;record type - data
f5fe : 2097f9           		jsr	HexToOutput
                        ;
                        ; Now print the proper number of bytes
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- ctmon65.asm ---------------------------------

                        ;
f601 : a000             Sloop2		ldy	#0
f603 : b1f0             		lda	(sptr),y	;get byte
f605 : 208df9           		jsr	updateCrc
f608 : 2097f9           		jsr	HexToOutput
f60b : 2033f9           		jsr	INCPT	;increment pointer
                        ;
f60e : ce99df           sdec		dec	tempA
f611 : d0ee             		bne	Sloop2
                        ;
                        ; Now print checksum
                        ;
f613 : ada9df           		lda	CHKL
f616 : 49ff             		eor	#$ff	;one's complement
f618 : 18               		clc
f619 : 6901             		adc	#1	;two's complement
f61b : 2097f9           		jsr	HexToOutput
                        ;
                        ; Output a CR/LF
                        ;
f61e : a90d             		lda	#CR
f620 : 20b1f9           		jsr	redirectedOutch
f623 : a90a             		lda	#LF
f625 : 20b1f9           		jsr	redirectedOutch
                        ;
                        ; If saving to disk, output a dot to indicate progress
                        ;
f628 : ad9adf           		lda	filename
f62b : f005             		beq	shf2
                        ;
f62d : a92e             		lda	#'.'
f62f : 202efb           		jsr	cout	;goes to console
                        ;
f632 : 38               shf2		sec
f633 : adabdf           		lda	Temp16L
f636 : edaadf           		sbc	ID
f639 : 8dabdf           		sta	Temp16L
f63c : adacdf           		lda	Temp16H
f63f : e900             		sbc	#0
f641 : 8dacdf           		sta	Temp16H
                        ;
f644 : 4c9bf5           		jmp	Sloop1
                        ;
                        ;=====================================================
                        ; Get a disk filename.
                        ;
f647 : a200             getFileName	ldx	#0
f649 : 203bfb           getFilename1	jsr	cin	;get next key
f64c : c90d             		cmp	#CR	;end of the input?
f64e : f027             		beq	getFnDone
f650 : c908             		cmp	#BS	;backspace?
f652 : f00d             		beq	getFnDel
f654 : e00c             		cpx	#FILENAME_SIZE	;check size
f656 : f0f1             		beq	getFilename1	;at length limit
f658 : 9d9adf           		sta	filename,x	;else save it
f65b : 202efb           		jsr	cout
f65e : e8               		inx
f65f : d0e8             		bne	getFilename1
                        ;
f661 : ca               getFnDel	dex
f662 : 3010             		bmi	getFnU	;no charac here
f664 : a908             		lda	#BS
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- ctmon65.asm ---------------------------------

f666 : 202efb           		jsr	cout
f669 : a920             		lda	#' '
f66b : 202efb           		jsr	cout
f66e : a908             		lda	#BS
f670 : 202efb           		jsr	cout
f673 : ca               		dex
f674 : e8               getFnU		inx		;can't go past start
f675 : 10d2             		bpl	getFilename1
f677 : a900             getFnDone       lda	#0	;terminate line
f679 : 9d9adf           		sta	filename,x
f67c : 4c07fb           		jmp	crlf
                        ;
                        ;=====================================================
                        ; Add the byte in A to the output buffer.  If the
                        ; buffer is full, flush it to disk.
                        ;
f67f : aea7df           putNextFileByte	ldx	diskBufOffset
f682 : e084             		cpx	#BUFFER_SIZE	;buffer full?
f684 : d00d             		bne	pNFB		;no
                        ;
                        ; The buffer is full, so write it out.
                        ;
f686 : 48               		pha			;save byte
f687 : a984             		lda	#BUFFER_SIZE
f689 : a2df             		ldx	#buffer>>8
f68b : a00a             		ldy	#buffer&$ff
f68d : 208afc           		jsr	DiskWrite
                        ;
f690 : a200             		ldx	#0		;reset index
f692 : 68               		pla
f693 : 9d0adf           pNFB		sta	buffer,x
f696 : e8               		inx
f697 : 8ea7df           		stx	diskBufOffset
f69a : 60               		rts
                        ;
                        ;*****************************************************
                        ; Dump the current registers based on values in the Sa
                        ; locations.
                        ;
f69b : 2091fa           DumpRegisters	jsr	putsil
f69e : 50433a00         		db	"PC:",0
f6a2 : ad92df           		lda	SavePC+1
f6a5 : 20eafa           		jsr	HexA
f6a8 : ad91df           		lda	SavePC
f6ab : 20eafa           		jsr	HexA
                        ;
f6ae : 2091fa           		jsr	putsil
f6b1 : 20413a00         		db	" A:",0
f6b5 : ad8edf           		lda	SaveA
f6b8 : 20eafa           		jsr	HexA
                        ;
f6bb : 2091fa           		jsr	putsil
f6be : 20583a00         		db	" X:",0
f6c2 : ad8fdf           		lda	SaveX
f6c5 : 20eafa           		jsr	HexA
                        ;
f6c8 : 2091fa           		jsr	putsil
f6cb : 20593a00         		db	" Y:",0
f6cf : ad90df           		lda	SaveY
f6d2 : 20eafa           		jsr	HexA
                        ;
f6d5 : 2091fa           		jsr	putsil
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- ctmon65.asm ---------------------------------

f6d8 : 2053503a00       		db	" SP:",0
f6dd : ad94df           		lda	SaveSP
f6e0 : 20eafa           		jsr	HexA
                        ;
                        ; Last is the condition register.  For this, print the
                        ; actual flags.  Lower case for clear, upper for set.
                        ;
f6e3 : 2091fa           		jsr	putsil
f6e6 : 20466c6167733a00 		db	" Flags:",0
                        	if	FULL_STATUS
                        ;
                        ; N - bit 7
                        ;
f6ee : a980             		lda	#$80	;bit to test
f6f0 : a24e             		ldx	#'N'	;set ACII char
f6f2 : 2021f7           		jsr	testbit
                        ;
                        ; V - bit 6
                        ;
f6f5 : a940             		lda	#$40	;bit to test
f6f7 : a256             		ldx	#'V'	;set ACII char
f6f9 : 2021f7           		jsr	testbit
                        ;
f6fc : a92d             		lda	#'-'	;unused bit
f6fe : 202efb           		jsr	cout
                        ;
                        ; B - bit 4
                        ;
f701 : a910             		lda	#$10	;bit to test
f703 : a242             		ldx	#'B'	;set ACII char
f705 : 2021f7           		jsr	testbit
                        ;
                        ; D - bit 3
                        ;
f708 : a908             		lda	#$08	;bit to test
f70a : a244             		ldx	#'D'	;set ACII char
f70c : 2021f7           		jsr	testbit
                        ;
                        ; I - bit 2
                        ;
f70f : a904             		lda	#$04	;bit to test
f711 : a249             		ldx	#'I'	;set ACII char
f713 : 2021f7           		jsr	testbit
                        ;
                        ; Z - bit 1
                        ;
f716 : a902             		lda	#$02	;bit to test
f718 : a25a             		ldx	#'Z'	;set ACII char
f71a : 2021f7           		jsr	testbit
                        ;
                        ; C - bit 0
                        ;
f71d : a901             		lda	#$01	;bit to test
f71f : a243             		ldx	#'C'	;set ACII char
                        ;
                        ; Fall through...
                        ;
                        ;*****************************************************
                        ; Given a bit mask in A and an upper case character
                        ; indicating the flag name in X, see if the flag is se
                        ; not.  Output upper case if set, lower case if not.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- ctmon65.asm ---------------------------------

f721 : 2d93df           testbit		and	SaveC	;is bit set?
f724 : d006             		bne	testbit1	;yes
f726 : 8a               		txa
f727 : 0920             		ora	#$20	;make lower case
f729 : 4c2efb           		jmp	cout
f72c : 8a               testbit1	txa
f72d : 4c2efb           		jmp	cout
                        	else
                        		lda	SaveSP
                        		jmp	HexA
                        	endif
                        ;
                        ;=====================================================
                        ; This continues executing from the last saved state,
                        ; such as from a call to DefaultNMI.
                        ;
f730 :                  doContinue
f730 : ae94df           		ldx	SaveSP
f733 : 9a               		txs
f734 : ad92df           		lda	SavePC+1
f737 : 48               		pha
f738 : ad91df           		lda	SavePC
f73b : 48               		pha
f73c : ad93df           		lda	SaveC
f73f : 48               		pha
f740 : ae8fdf           		ldx	SaveX
f743 : ac90df           		ldy	SaveY
f746 : ad8edf           		lda	SaveA
f749 : 40               		rti
                        ;
                        ;=====================================================
                        ; This gets two hex characters and returns the value
                        ; in A with carry clear.  If a non-hex digit is
                        ; entered, then A contans the offending character and
                        ; carry is set.
                        ;
f74a : 2062f7           getHex		jsr	getNibble
f74d : b020             		bcs	getNibBad
f74f : 0a               		asl	a
f750 : 0a               		asl	a
f751 : 0a               		asl	a
f752 : 0a               		asl	a
f753 : 29f0             		and	#$f0
f755 : 8d99df           		sta	tempA
f758 : 2062f7           		jsr	getNibble
f75b : b012             		bcs	getNibBad
f75d : 0d99df           		ora	tempA
f760 : 18               		clc
f761 : 60               		rts
                        ;
                        ; Helper.  Gets next input char and converts to a
                        ; value from 0-F in A and returns C clear.  If not a
                        ; valid hex character, return C set.
                        ;
f762 : 20f6f9           getNibble	jsr	redirectedGetch
f765 : a20f             		ldx	#nibbleHexEnd-nibbleHex-1
f767 : dd74f7           getNibble1	cmp	nibbleHex,x
f76a : f005             		beq	getNibF	;got match
f76c : ca               		dex
f76d : 10f8             		bpl	getNibble1
f76f : 38               getNibBad	sec
f770 : 60               		rts
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- ctmon65.asm ---------------------------------

                        
f771 : 8a               getNibF		txa		;index is value
f772 : 18               		clc
f773 : 60               		rts
                        ;
f774 : 30313233343536.. nibbleHex	db	"0123456789ABCDEF"
f784 =                  nibbleHexEnd	equ	*
                        ;
                        ;=====================================================
                        ; Gets a four digit hex address amd places it in
                        ; SAL and SAH.  Returns C clear if all is well, or C
                        ; set on error and A contains the character.
                        ;
f784 : 204af7           getStartAddr	jsr	getHex
f787 : b00c             		bcs	getDone
f789 : 8d96df           		sta	SAH
f78c : 204af7           		jsr	getHex
f78f : b004             		bcs	getDone
f791 : 8d95df           		sta	SAL
f794 : 18               		clc
f795 : 60               getDone		rts
                        ;
                        ;=====================================================
                        ; Gets a four digit hex address and places it in
                        ; EAL and EAH.  Returns C clear if all is well, or C
                        ; set on error and A contains the character.
                        ;
f796 : 204af7           getEndAddr	jsr	getHex
f799 : b0fa             		bcs	getDone
f79b : 8d98df           		sta	EAH
f79e : 204af7           		jsr	getHex
f7a1 : b0f2             		bcs	getDone
f7a3 : 8d97df           		sta	EAL
f7a6 : 18               		clc
f7a7 : 60               		rts
                        ;
                        ;=====================================================
                        ; Get an address range and leave them in SAL and EAL.
                        ;
f7a8 : 2091fa           getAddrRange	jsr	putsil
f7ab : 53746172743a2000 		db	"Start: ",0
f7b3 : 2084f7           		jsr	getStartAddr
f7b6 : b0dd             		bcs	getDone
f7b8 : 2091fa           		jsr	putsil
f7bb : 2c20456e643a2000 		db	", End: ",0
f7c3 : 2096f7           		jsr	getEndAddr
f7c6 : 60               		rts
                        ;
                        ;=====================================================
                        ; Command handler for the ? command
                        ;
f7c7 : 2091fa           showHelp	jsr	putsil
f7ca : 0d0a             		db	CR,LF
f7cc : 417661696c6162.. 		db	"Available commands:"
f7df : 0d0a0a00         		db	CR,LF,LF,0
                        ;
                        ; Print help for built-in commands...
                        ;
f7e3 : a9f3             		lda	#commandTable&$ff
f7e5 : 85f0             		sta	sptr
f7e7 : a9f0             		lda	#commandTable/256
f7e9 : 85f1             		sta	sptr+1
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- ctmon65.asm ---------------------------------

f7eb : 20f1f7           		jsr	displayHelp	;display help
                        ;
                        ; Now print help for the extension commands...
                        ;
                        	if	EXTENDED_CMDS
                        		lda	ExtensionAddr
                        		sta	sptr
                        		lda	ExtensionAddr+1
                        		sta	sptr+1
                        		jsr	displayHelp
                        		jsr	crlf
                        	endif
f7ee : 4cb7f0           		jmp	prompt
                        ;
                        ;=====================================================
                        ; Given a pointer to a command table in POINT, display
                        ; the help text for all commands in the table.
                        ;
f7f1 : a000             displayHelp	ldy	#0	;index into command table
f7f3 : b1f0             showHelpLoop	lda	(sptr),y	;get command
f7f5 : f01c             		beq	showHelpDone	;jump if at end
                        ;
                        ; Display this entry's descriptive text
                        ;
f7f7 : c8               		iny		;skip over command
f7f8 : c8               		iny		;skip over function ptr
f7f9 : c8               		iny
f7fa : b1f0             		lda	(sptr),y
f7fc : 85f2             		sta	INL
f7fe : c8               		iny
f7ff : b1f0             		lda	(sptr),y
f801 : 85f3             		sta	INH
f803 : 98               		tya
f804 : 48               		pha
f805 : 2017fb           		jsr	space2
f808 : 20b4fa           		jsr	puts	;print description
f80b : 2007fb           		jsr	crlf
f80e : 68               		pla
f80f : a8               		tay
f810 : c8               		iny		;point to next entry
f811 : d0e0             		bne	showHelpLoop
f813 : 60               showHelpDone	rts
                        ;
                        ;=====================================================
                        ; This does a memory test of a region of memory.
                        ;
                        ; Asks for the starting and ending locations.
                        ;
                        ; This cycles a rolling bit, then adds a ninth
                        ; pattern to help detect shorted address bits.
                        ; Ie: 01, 02, 04, 08, 10, 20, 40, 80, BA
                        ;
df8e =                  pattern		equ	SaveA	;re-use some other locations
df8f =                  original	equ	SaveX
                        ;
                        ; Test patterns
                        ;
0001 =                  PATTERN_0	equ	$01
00ba =                  PATTERN_9	equ	$ba
                        ;
f814 : 203bfb           memabort	jsr	cin	;eat pending key
f817 : 4cb7f0           cmdRet2		jmp	prompt
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- ctmon65.asm ---------------------------------

                        ;
f81a : 2091fa           memTest		jsr	putsil
f81d : 4d656d6f727920.. 		db	"Memory test ",0
f82a : 20a8f7           		jsr	getAddrRange	;get range
f82d : b0e8             		bcs	cmdRet2		;branch if abort
                        ;
f82f : 2091fa           		jsr	putsil
f832 : 0d0a             		db	CR,LF
f834 : 54657374696e67.. 		db	"Testing memory.  Press any key to abort"
f85b : 00               		db	0
f85c : a901             		lda	#PATTERN_0	;only set initial...
f85e : 8d8edf           		sta	pattern		;..pattern once
                        ;
                        ; Start of loop.  This fills/tests one complete pass
                        ; of memory.
                        ;
f861 : 2046fb           memTestMain	jsr	cstatus	;key pressed?
f864 : d0ae             		bne	memabort	;branch if yes
f866 : ad95df           		lda	SAL	;reset pointer to start
f869 : 85f0             		sta	sptr
f86b : ad96df           		lda	SAH
f86e : 85f1             		sta	sptr+1
                        ;
                        ; Fill memory with the rolling pattern until the last
                        ; location is filled.
                        ;
f870 : a000             		ldy	#0
f872 : ad8edf           		lda	pattern
f875 : 8d8fdf           		sta	original
f878 : 91f0             memTestFill	sta	(sptr),y
f87a : c9ba             		cmp	#PATTERN_9	;at last pattern?
f87c : d005             		bne	memFill3
f87e : a901             		lda	#PATTERN_0	;restart pattern
f880 : 4c88f8           		jmp	memFill4
                        ;
                        ; Rotate pattern left one bit
                        ;
f883 : 0a               memFill3	asl	a
f884 : 9002             		bcc	memFill4	;branch if not overflow
f886 : a9ba             		lda	#PATTERN_9	;ninth pattern
                        ;
                        ; The new pattern is in A.  Now see if we've reached
                        ; the end of the area to be tested.
                        ;
f888 : 48               memFill4	pha		;save pattern
f889 : a5f0             		lda	sptr
f88b : cd97df           		cmp	EAL
f88e : d007             		bne	memFill5
f890 : a5f1             		lda	sptr+1
f892 : cd98df           		cmp	EAH
f895 : f007             		beq	memCheck
                        ;
                        ; Not done, so move to next address and keep going.
                        ;
f897 : 2033f9           memFill5	jsr	INCPT
f89a : 68               		pla		;recover pattern
f89b : 4c78f8           		jmp	memTestFill
                        ;
                        ; Okay, memory is filled, so now go back and test it.
                        ; We kept a backup copy of the initial pattern to
                        ; use, but save the current pattern as the starting
                        ; point for the next pass.
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- ctmon65.asm ---------------------------------

                        ;
f89e : 68               memCheck	pla
f89f : 8d8edf           		sta	pattern	;for next pass
f8a2 : ad95df           		lda	SAL	;reset pointer to start
f8a5 : 85f0             		sta	sptr
f8a7 : ad96df           		lda	SAH
f8aa : 85f1             		sta	sptr+1
f8ac : ad8fdf           		lda	original	;restore initial pattern
f8af : a000             		ldy	#0
f8b1 : d1f0             memTest2	cmp	(sptr),y
f8b3 : d02c             		bne	memFail
f8b5 : c9ba             		cmp	#PATTERN_9
f8b7 : d004             		bne	memTest3
                        ;
                        ; Time to reload the pattern
                        ;
f8b9 : a901             		lda	#PATTERN_0
f8bb : d005             		bne	memTest4
                        ;
                        ; Rotate pattern left one bit
                        ;
f8bd : 0a               memTest3	asl	a
f8be : 9002             		bcc	memTest4
f8c0 : a9ba             		lda	#PATTERN_9
                        ;
                        ; The new pattern is in A.
                        ;
f8c2 : 48               memTest4	pha		;save pattern
f8c3 : a5f0             		lda	sptr
f8c5 : cd97df           		cmp	EAL
f8c8 : d007             		bne	memTest5	;not at end
f8ca : a5f1             		lda	sptr+1
f8cc : cd98df           		cmp	EAH
f8cf : f007             		beq	memDone	;at end of pass
                        ;
                        ; Not at end yet, so inc pointer and continue
                        ;
f8d1 : 2033f9           memTest5	jsr	INCPT
f8d4 : 68               		pla
f8d5 : 4cb1f8           		jmp	memTest2
                        ;
                        ; Another pass has completed.
                        ;
f8d8 : 68               memDone		pla
f8d9 : a92e             		lda	#'.'
f8db : 202efb           		jsr	cout
f8de : 4c61f8           		jmp	memTestMain
                        ;
                        ; Failure.  Display the failed address, the expected
                        ; value and what was actually there.
                        ;
f8e1 : 48               memFail		pha		;save pattern for error report
f8e2 : 2091fa           		jsr	putsil
f8e5 : 0d0a             		db	CR,LF
f8e7 : 4661696c757265.. 		db	"Failure at address ",0
f8fb : a5f1             		lda	sptr+1
f8fd : 20eafa           		jsr	HexA
f900 : a5f0             		lda	sptr
f902 : 20eafa           		jsr	HexA
f905 : 2091fa           		jsr	putsil
f908 : 2e202045787065.. 		db	".  Expected ",0
f915 : 68               		pla
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- ctmon65.asm ---------------------------------

f916 : 20eafa           		jsr	HexA
f919 : 2091fa           		jsr	putsil
f91c : 2062757420676f.. 		db	" but got ",0
f926 : a000             		ldy	#0
f928 : b1f0             		lda	(sptr),y
f92a : 20eafa           		jsr	HexA
f92d : 2007fb           		jsr	crlf
f930 : 4cb7f0           cmdRet4		jmp	prompt
                        ;
                        ;=====================================================
                        ; Increment sptr
                        ;
f933 : e6f0             INCPT		inc	sptr
f935 : d002             		bne	incpt2
f937 : e6f1             		inc	sptr+1
f939 : 60               incpt2		rts
                        ;
                        ;=====================================================
                        ; Ping the Arduino disk controller.  This just sends t
                        ; PING command gets back one character, then returns.
                        ; Not much of a test but is sufficient to prove the
                        ; link is working.
                        ;
f93a : 2091fa           pingDisk	jsr	putsil
f93d : 50696e672e2e2e.. 		db	"Ping... ",0
f946 : 20d4fb           		jsr	DiskPing
f949 : 2091fa           		jsr	putsil
f94c : 7375636365737321 		db	"success!"
f954 : 0d0a00           		db	CR,LF,0
f957 : 4cb7f0           doDiskDirEnd	jmp	prompt
                        ;
                        ;=====================================================
                        ; Do a disk directory of the SD card.
                        ;
f95a : 2091fa           doDiskDir	jsr	putsil
f95d : 4469736b204469.. 		db	"Disk Directory..."
f96e : 0d0a00           		db	CR,LF,0
                        ;		jsr	xParInit
f971 : 20e7fb           		jsr	DiskDir
                        ;
                        ; Get/Display each entry
                        ;
f974 : a2df             doDiskDirLoop   ldx	#filename/256	;pointer to buffer
f976 : a09a             		ldy	#filename&$ff
f978 : 86f3             		stx	INH		;save for puts
f97a : 84f2             		sty	INL
f97c : 20f1fb           		jsr	DiskDirNext	;get next entry
f97f : b0d6             		bcs	doDiskDirEnd	;carry = end of list
f981 : 2014fb           		jsr	space3
f984 : 20b4fa           		jsr	puts		;else print name
f987 : 2007fb           		jsr	crlf
f98a : 4c74f9           		jmp	doDiskDirLoop	;do next entry
                        ;
                        ;=====================================================
                        ; Adds the character in A to the CRC.  Preserves A.
                        ;
f98d : 48               updateCrc	pha
f98e : 18               		clc
f98f : 6da9df           		adc	CHKL
f992 : 8da9df           		sta	CHKL
f995 : 68               		pla
f996 : 60               		rts
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; Print character in A as two hex digits to the
                        ; current output device (console or file).
                        ;
f997 : 48               HexToOutput	pha		;save return value
f998 : 48               		pha
f999 : 4a               		lsr	a	;move top nibble to bottom
f99a : 4a               		lsr	a
f99b : 4a               		lsr	a
f99c : 4a               		lsr	a
f99d : 20a6f9           		jsr	hexta	;output nibble
f9a0 : 68               		pla
f9a1 : 20a6f9           		jsr	hexta
f9a4 : 68               		pla		;restore
f9a5 : 60               		rts
                        ;
f9a6 : 290f             hexta		and	#%0001111
f9a8 : c90a             		cmp	#$0a
f9aa : 18               		clc
f9ab : 3002             		bmi	hexta1
f9ad : 6907             		adc	#7
f9af : 6930             hexta1		adc	#'0'	;then fall into...
                        ;
                        ;=====================================================
                        ; This is a helper function used for redirected I/O.
                        ; It simply does a jump through the output vector
                        ; pointer to send the character in A to the proper
                        ; device.
                        ;
f9b1 : 6c08df           redirectedOutch	jmp	(outputVector)
                        ;
                        ;=====================================================
                        ; Set up the output vector to point to the normal
                        ; console output subroutine.
                        ;
f9b4 :                  setOutputConsole
f9b4 : a92e             		lda	#cout&$ff
f9b6 : 8d08df           		sta     outputVector
f9b9 : a9fb             		lda	#cout/256
f9bb : 8d09df           		sta	outputVector+1
f9be : 60               		rts
                        ;
                        ;=====================================================
                        ; Set up the output vector to point to a file write
                        ; subroutine.
                        ;
f9bf : a97f             setOutputFile	lda	#putNextFileByte&$ff
f9c1 : 8d08df           		sta     outputVector
f9c4 : a9f6             		lda	#putNextFileByte/256
f9c6 : 8d09df           		sta	outputVector+1
                        ;
                        ; Clear counts and offsets so the next read will
                        ; cause the file to be read.
                        ;
f9c9 : a900             		lda	#0
f9cb : 8da7df           		sta	diskBufOffset
f9ce : 60               		rts
                        ;
                        ;=====================================================
                        ; Set up the input vector to point to the normal
                        ; console input subroutine.
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- ctmon65.asm ---------------------------------

                        ;
f9cf : a9da             setInputConsole	lda	#cinecho&$ff
f9d1 : 8d06df           		sta     inputVector
f9d4 : a9f9             		lda	#cinecho/256
f9d6 : 8d07df           		sta	inputVector+1
f9d9 : 60               		rts
                        ;
f9da : 203bfb           cinecho		jsr	cin
f9dd : 48               		pha
f9de : 202efb           		jsr	cout
f9e1 : 68               		pla
f9e2 : 60               		rts
                        ;
                        ;=====================================================
                        ; Set up the input vector to point to a file read
                        ; subroutine.
                        ;
f9e3 : a9f9             setInputFile    lda	#getNextFileByte&$ff
f9e5 : 8d06df           		sta     inputVector
f9e8 : a9f9             		lda	#getNextFileByte/256
f9ea : 8d07df           		sta	inputVector+1
                        ;
                        ; Clear counts and offsets so the next read will
                        ; cause the file to be read.
                        ;
f9ed : a900             		lda	#0
f9ef : 8da7df           		sta	diskBufOffset
f9f2 : 8da8df           		sta	diskBufLength
f9f5 : 60               		rts
                        ;
                        ;=====================================================
                        ; This is a helper function used for redirected I/O.
                        ; It simply does a jump through the input vector
                        ; pointer to get the next input character.
                        ;
f9f6 : 6c06df           redirectedGetch	jmp	(inputVector)
                        ;
                        ;=====================================================
                        ; This gets the next byte from an open disk file.  If
                        ; there are no more bytes left, this returns C set.
                        ; Else, C is clear and A contains the character.
                        ;
f9f9 : aea7df           getNextFileByte ldx 	diskBufOffset
f9fc : eca8df           		cpx	diskBufLength
f9ff : d014             		bne	hasdata		;branch if still data
                        ;
                        ; There is no data left in the buffer, so read a
                        ; block from the SD system.
                        ;
fa01 : a984             		lda	#BUFFER_SIZE
fa03 : a2df             		ldx	#buffer>>8
fa05 : a00a             		ldy	#buffer&$ff
fa07 : 2058fc           		jsr	DiskRead
fa0a : b012             		bcs	getNextEof
                        ;
                        ; A contains the number of bytes actually read.
                        ;
fa0c : 8da8df           		sta	diskBufLength	;save length
fa0f : c900             		cmp	#0		;shouldn't happen
fa11 : f00b             		beq	getNextEof
                        ;
fa13 : a200             		ldx	#0
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- ctmon65.asm ---------------------------------

fa15 : bd0adf           hasdata		lda	buffer,x
fa18 : e8               		inx
fa19 : 8ea7df           		stx	diskBufOffset
fa1c : 18               		clc
fa1d : 60               		rts
                        ;
fa1e : a900             getNextEof	lda	#0
fa20 : 8da7df           		sta	diskBufOffset
fa23 : 8da8df           		sta	diskBufLength
fa26 : 38               		sec
fa27 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; Type the contents of an SD file to console.
                        ;
fa28 : 2091fa           typeFile	jsr	putsil
fa2b : 456e7465722066.. 		db	"Enter filename to type: ",0
fa44 : 2047f6           		jsr	getFileName
fa47 : a09a             		ldy	#filename&$ff
fa49 : a2df             		ldx	#filename/256
                        ;		jsr	xParInit
fa4b : 2022fc           		jsr	DiskOpenRead
fa4e : 901e             		bcc	typeFile1	;opened ok
                        ;
fa50 : 2091fa           		jsr	putsil
fa53 : 0d0a             		db	CR,LF
fa55 : 4661696c656420.. 		db	"Failed to open file"
fa68 : 0d0a00           		db	CR,LF,0
fa6b : 4cb7f0           		jmp	prompt
                        ;
                        ; Now just keep reading in bytes and displaying them.
                        ;
fa6e : 20e3f9           typeFile1	jsr	setInputFile	;reading from file
fa71 : 20f9f9           typeFileLoop	jsr	getNextFileByte
fa74 : b006             		bcs	typeEof
fa76 : 202efb           		jsr	cout	;display character
fa79 : 4c71fa           		jmp	typeFileLoop
                        ;
fa7c : 20c1fc           typeEof		jsr	DiskClose
fa7f : 4cb7f0           		jmp	prompt
                        ;
                        ;=====================================================
                        ; This flushes any data remaining in the disk buffer
                        ; and then closes the file.
                        ;
fa82 : ada7df           CloseOutFile	lda	diskBufOffset
fa85 : f007             		beq	closeonly
fa87 : a2df             		ldx	#buffer>>8
fa89 : a00a             		ldy	#buffer&$ff
fa8b : 208afc           		jsr	DiskWrite
                        ;
fa8e : 4cc1fc           closeonly	jmp	DiskClose
                        ;
                        		include	"io.asm"
                        ;*****************************************************
                        ; FILE: io.asm
                        ;
                        ; This contains slightly higher level console related
                        ; functions like text output, reading a line, etc.
                        ;*****************************************************
                        ;
                        ;		zpage
                        ;putsp		ds	2
                        ;
                        		bss
dfad =                  BUFFER		ds	BUFFER_SIZE
e031 =                  argc		ds	1
e032 =                  argv		ds	MAX_ARGC
                        ;
                        		code
                        ;
                        ;*****************************************************
                        ; Print the string that follows the JSR to this code.
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- ctmon65.asm ---------------------------------

                        ; Taken from http://www.6502.org/source/io/primm.htm
                        ; The last example by Ross Archer.
                        ;
fa91 : 68               putsil		pla		;Get the low part of "return" address
                        				;(data start address)
fa92 : 85f4             		sta	putsp
fa94 : 68               		pla
fa95 : 85f5             		sta	putsp+1	;Get the high part of "return" address
                        				;(data start address)
                        				;Note: actually we're pointing one short
fa97 : a001             PSINB		ldy	#1
fa99 : b1f4             		lda	(putsp),y	;Get the next string character
fa9b : e6f4             		inc	putsp	;update the pointer
fa9d : d002             		bne	PSICHO	;if not, we're pointing to next character
fa9f : e6f5             		inc	putsp+1	;account for page crossing
faa1 : 0900             PSICHO		ora	#0	;Set flags according to contents of
                        				;   Accumulator
faa3 : f006             		beq	PSIX1	;don't print the final NULL
faa5 : 202efb           		jsr	cout	;write it out
faa8 : 4c97fa           		jmp	PSINB	;back around
faab : e6f4             PSIX1		inc	putsp
faad : d002             		bne	PSIX2
faaf : e6f5             		inc	putsp+1	;account for page crossing
fab1 : 6cf400           PSIX2		jmp	(putsp)	;return to byte following final NUL
                        ;
                        ;=====================================================
                        ; This prints the null terminated string pointed to by
                        ; INL and INH.  Modifies those locations to point to
                        ; the end of the string.
                        ;
fab4 : a000             puts		ldy	#0
fab6 : b1f2             putsy		lda	(INL),y
fab8 : e6f2             		inc	INL
faba : d002             		bne	puts1
fabc : e6f3             		inc	INH
fabe : 0900             puts1		ora	#0
fac0 : f00c             		beq	putsdone
fac2 : 8c90df           		sty	SaveY
fac5 : 202efb           		jsr	cout	;print character
fac8 : ac90df           		ldy	SaveY
facb : 4cb6fa           		jmp	putsy
face : 60               putsdone	rts
                        ;
                        ;*****************************************************
                        ; Get a line of text from the console and put it into
                        ; BUFFER.  This only allows printable characters, will
                        ; limit the amount of text to BUFFER_SIZE-1 characters
                        ; and allows some editing.  Returns the string with a 
                        ; byte at the end and the length in A.  If the length 
                        ; zero, return Z set.
                        ;
facf :                  getline
                        	if 0
                        		ldx	#0
                        		beq	getline1
                        ;
                        ; This outputs a bell.  Used when the user
                        ; does something bad, like non-printable
                        ; characters or exceeding line length.
                        ;
                        getline2	lda	#BELL
                        		jsr	cout
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ; Get the next character
                        ;
                        getline1	jsr	cin	;get character
                        		cmp	#' '
                        		bcc	getline2	;not printable
                        		cmp	#'~'+1
                        		bcs	getline2	;not printable
                        		cmp	#CR	;end of input?
                        		beq	getline3
                        		cpx	#BUFFER_SIZE-1
                        		beq	getline1	;too long
                        		sta	BUFFER,x
                        		jsr	cout	;echo, echo, echo...
                        		inx
                        		bne	getline1
                        ;
                        ; Got a CR, so terminate the string.
                        ;
                        getline3	lda	#0
                        		sta	BUFFER,x
                        		txa		;will set/clear Z
                        	endif
facf : 60               		rts
                        ;
                        ;*****************************************************
                        ; This converts the buffer to all lower case.
                        ;
fad0 : a200             ToLower		ldx	#0
fad2 : bdaddf           ToLower1	lda	BUFFER,x
fad5 : f011             		beq	ToLowerDone
                        ;
fad7 : c961             		cmp	#'a'
fad9 : 900a             		bcc	ToLower2
fadb : c97b             		cmp	#'z'+1
fadd : b006             		bcs	ToLower2
fadf : 18               		clc
fae0 : e920             		sbc	#$20	;convert
fae2 : 9daddf           		sta	BUFFER,x
fae5 : e8               ToLower2	inx
fae6 : d0ea             		bne	ToLower1
                        ;
fae8 : 60               ToLowerDone	rts
                        ;
                        ;*****************************************************
                        ; This parses the current contents of BUFFER.  It scan
                        ; until finding whitespace, terminates the string (put
                        ; null), then scans until finding the next non-whitesp
                        ; and repeats the process again.  Saves the offset to 
                        ; word in argc, and has a total count in argv.  Yes, I
                        ; a C programmer.
                        ;
fae9 :                  parse
                        	if 0
                        		ldx	#0
                        		stx	argc	;clear count
                        		dex
                        ;
                        ; Skip whitespace
                        ;
                        parse1		inx
                        		lda	BUFFER,x
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- ctmon65.asm ---------------------------------

                        		beq	parse2	;at EOL
                        		cmp	#' '
                        		beq	parse1	;whitespace
                        ;
                        ; Not whitespace
                        ;
                        		ldy	argc
                        		stx	argv,y
                        		iny
                        		cpy	#MAX_ARGC
                        		beq	parse2
                        		sty	argv
                        ;
                        ; Now skip until whitespace found again
                        ;
                        parse3		inx
                        		lda	BUFFER,x
                        		beq	parse2
                        		cmp	#' '
                        		bne	parse3
                        		lda	#0
                        		sta	BUFFER,x	;terminate
                        		jmp	parse1
                        ;
                        	endif
fae9 : 60               parse2		rts
                        ;
                        ;*****************************************************
                        ; Dump the contents of A as two hex digits.  Preserves
                        ; all registers.
                        ;
faea : 48               HexA		pha		;save value
faeb : 48               		pha
faec : 4a               		lsr	a
faed : 4a               		lsr	a
faee : 4a               		lsr	a
faef : 4a               		lsr	a
faf0 : 20f9fa           		jsr	HexDigit
faf3 : 68               		pla
faf4 : 20f9fa           		jsr	HexDigit
faf7 : 68               		pla		;restore value
faf8 : 60               		rts
                        ;
faf9 : 290f             HexDigit	and	#$0f
fafb : c90a             		cmp	#$0a
fafd : 18               		clc
fafe : 3002             		bmi	HexDigit1
fb00 : 6907             		adc	#7
fb02 : 6930             HexDigit1	adc	#'0'
fb04 : 4c2efb           		jmp	cout
                        ;
                        ;*****************************************************
                        ; Output a CR/LF combination to the console.  Preserve
                        ; all registers.
                        ;
fb07 : 48               crlf		pha
fb08 : a90d             		lda	#CR
fb0a : 202efb           		jsr	cout
fb0d : a90a             		lda	#LF
fb0f : 202efb           		jsr	cout
fb12 : 68               		pla
fb13 : 60               		rts
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;*****************************************************
                        ; Output one, two or three spaces.  Preserves all
                        ; register.
                        ;
fb14 : 201afb           space3		jsr	space
fb17 : 201afb           space2		jsr	space
fb1a : 48               space		pha
fb1b : a920             		lda	#' '
fb1d : 202efb           		jsr	cout
fb20 : 68               		pla
fb21 : 60               		rts
                        
                        
                        
                        		include	"acia.asm"
                        ;*****************************************************
                        ; FILE: acia.asm
                        ;*****************************************************
                        ;
0001 =                  CONSOLE_SLOT	equ	1
                        ;
e010 =                  ACIA		equ	(CONSOLE_SLOT*IO_SIZE)+IO_BASE
0001 =                  RDRF		equ	%00000001
0002 =                  TDRE		equ	%00000010
                        ;
                        ;*****************************************************
                        ; Initialize the ACIA
                        ;
fb22 : a903             cinit		lda	#%00000011	;reset
fb24 : 8d10e0           		sta	ACIA
fb27 : ea               		nop
fb28 : a911             		lda	#%00010001	;8N2
fb2a : 8d10e0           		sta	ACIA
fb2d : 60               		rts
                        ;
                        ;*****************************************************
                        ; Output the character in A to the console.  This will
                        ; block until the character is queued.  Preserves all
                        ; registers.
                        ;
fb2e : 48               cout		pha
fb2f : ad10e0           cout1		lda	ACIA
fb32 : 2902             		and	#TDRE
fb34 : f0f9             		beq	cout1		;not empty
fb36 : 68               		pla
fb37 : 8d11e0           		sta	ACIA+1
fb3a : 60               		rts
                        ;
                        ;*****************************************************
                        ; Gets a character from the console and returns it in 
                        ; Modifies no other registers.  This blocks until a
                        ; character is available.
                        ;
fb3b : ad10e0           cin		lda	ACIA
fb3e : 2901             		and	#RDRF
fb40 : f0f9             		beq	cin
fb42 : ad11e0           		lda	ACIA+1
fb45 : 60               		rts
                        ;
                        ;*****************************************************
                        ; Get the status of the console.  Returns Z set if no
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- ctmon65.asm ---------------------------------

                        ; characters are available, Z clear if a character is
                        ; ready.
                        ;
fb46 : ad10e0           cstatus		lda	ACIA
fb49 : 2901             		and	#RDRF
fb4b : 60               		rts
                        
                        	if SD_ENABLED
                        		include	"parproto.inc"
                        ;*****************************************************
                        ; Parallel port protocol
                        ;
                        ; This is the header file for making applications
                        ; compliant with The Remote Disk Protocol Guide which
                        ; is on the Corsham Technologies web page somewhere:
                        ;
                        ;    www.corshamtech.com
                        ;
                        ; This was updated 06/13/2015 to be compliant with the
                        ; official specification, so the opcode values changed
                        ;
                        ; Another update on 09/04/2017
                        ;
                        ;=====================================================
                        ; Commands from host to Arduino
                        ;
0001 =                  PC_GET_VERSION	equ	$01
0005 =                  PC_PING		equ	$05	;ping Arduino
0006 =                  PC_LED_CONTROL	equ	$06	;LED control
0010 =                  PC_GET_DIR	equ	$10	;Get directory
0011 =                  PC_GET_MOUNTED	equ	$11	;Get mounted drive list
0012 =                  PC_MOUNT	equ	$12	;Mount drive
0013 =                  PC_UNMOUNT	equ	$13	;Unmount drive
0014 =                  PC_GET_STATUS	equ	$14	;Get status for one drive
0015 =                  PC_DONE		equ	$15	;Stop data
0015 =                  PC_ABORT	equ	PC_DONE
0016 =                  PC_READ_FILE	equ	$16	;Read regular file (non-DSK)
0017 =                  PC_READ_BYTES	equ	$17	;Read sequential bytes
0018 =                  PC_RD_SECTOR	equ	$18	;Read FLEX sector
0019 =                  PC_WR_SECTOR	equ	$19	;Write FLEX sector
001a =                  PC_GET_MAX	equ	$1a	;Get maximum drives
001b =                  PC_WRITE_FILE   equ	$1b	;Open file for writing
001c =                  PC_WRITE_BYTES	equ	$1c	;Data to be written
001d =                  PC_SAVE_CONFIG	equ	$1d	;Save SD.CFG with current value
001e =                  PC_SET_TIMER	equ	$1e	;Set RTC timer
001f =                  PC_WR_SEC_LONG	equ	$1f	;Write sector with long sec num
0020 =                  PC_RD_SEC_LONG	equ	$20	;Read sector with long sec num
                        ;
                        ;=====================================================
                        ; Responses from Arduino to host
                        ;
0081 =                  PR_VERSION_INFO	equ	$81	;Contains version information
0082 =                  PR_ACK		equ	$82	;ACK (no additional information)
0083 =                  PR_NAK		equ	$83	;NAK - one status byte follows
0085 =                  PR_PONG		equ	$85	;Reply to a ping
0090 =                  PR_DIR_ENTRY	equ	$90	;Directory entry
0091 =                  PR_DIR_END	equ	$91	;End of directory entries
0092 =                  PR_FILE_DATA	equ	$92	;File data
0093 =                  PR_STATUS	equ	$93	;Drive status
0094 =                  PR_SECTOR_DATA	equ	$94	;Sector data
0095 =                  PR_MOUNT_INFO	equ	$95	;Mount entry
0096 =                  PR_MAX_DRIVES	equ	$96	;Maximum number of drives
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;=====================================================
                        ; Error codes for NAK events.  Yes, these are in
                        ; decimal due to an error in the original
                        ; documentation.
                        ;
0000 =                  ERR_NONE	equ	0
000a =                  ERR_NOT_MOUNTED	equ	10
000b =                  ERR_MOUNTED	equ	11
000c =                  ERR_NOT_FOUND	equ	12
000d =                  ERR_READ_ONLY	equ	13
000e =                  ERR_BAD_DRIVE	equ	14
000f =                  ERR_BAD_TRACK	equ	15
0010 =                  ERR_BAD_SECTOR	equ	16
0011 =                  ERR_READ_ERROR	equ	17
0012 =                  ERR_WRITE_ERROR	equ	18
0013 =                  ERR_NOT_PRESENT	equ	19
0014 =                  ERR_NOT_IMPL	equ	20	;Command not implemented
                        
                        
                        		include	"pario.asm"
                        
                        ;CTMON65 version using a 6821
                        
                        ;*****************************************************
                        ; These are the low-level I/O routines to talk to the
                        ; Arduino processor connected to the KIM's I/O port.
                        ;
                        ; August 2014, Bob Applegate K2UT, bob@corshamtech.com
                        ;
                        ; Which port bits are used for what:
                        ;
                        ; A0 = Data 0, alternates input/output
                        ; A1 = Data 1, alternates input/output
                        ; A2 = Data 2, alternates input/output
                        ; A3 = Data 3, alternates input/output
                        ; A4 = Data 4, alternates input/output
                        ; A5 = Data 5, alternates input/output
                        ; A6 = Data 6, alternates input/output
                        ; A7 = Data 7, alternates input/output
                        ;
                        ; B0 = Direction bit, always output
                        ; B1 = Write strobe or ACK, always output
                        ; B2 = Read stroke or ACK, always input
                        ;
                        ;----------------------------------------------------
                        ; Bits in the B register
                        ;
0001 =                  DIRECTION	equ	%00000001
0002 =                  PSTROBE		equ	%00000010
0004 =                  ACK		equ	%00000100
                        ;
                        ;----------------------------------------------------
                        ; Which slot the parallel board is in.  This needs to
                        ; be set for the system in use.  As long as the user
                        ; programs only call functions in here, no other
                        ; file/application should know which slot the board
                        ; is in.
                        ;
0006 =                  PIASLOT		equ	6
                        ;
                        ; Computed addresses of 6821 registers
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- ctmon65.asm ---------------------------------

                        ;
e060 =                  PIABASE		equ	IO_BASE+(PIASLOT*IO_SIZE)
e060 =                  PIAREGA		equ	PIABASE		;data reg A
e060 =                  PIADDRA		equ	PIABASE		;data dir reg A
e061 =                  PIACTLA		equ	PIABASE+1	;control reg A
e062 =                  PIAREGB		equ	PIABASE+2	;data reg B
e062 =                  PIADDRB		equ	PIABASE+2	;data dir reg B
e063 =                  PIACTLB		equ	PIABASE+3	;control reg B
                        		code
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- ctmon65.asm ---------------------------------

                        ;
                        ;*****************************************************
                        ; This is the initialization function.  Call before
                        ; doing anything else with the parallel port.
                        ;
fb4c :                  xParInit
                        ;
                        ; Set up the data direction register for port B so tha
                        ; the DIRECTION and PSTROBE bits are output.
                        ;
fb4c : a900             		lda	#0	;select DDR
fb4e : 8d63e0           		sta	PIACTLB	;...for port B
fb51 : a903             		lda	#DIRECTION | PSTROBE
fb53 : 8d62e0           		sta	PIADDRB
fb56 : a904             		lda	#4	;select data reg
fb58 : 8d63e0           		sta	PIACTLB
                        ;
                        ; Fall through to set up for writes...
                        ;
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- ctmon65.asm ---------------------------------

                        ;*****************************************************
                        ; This sets up for writing to the Arduino.  Sets up
                        ; direction registers, drives the direction bit, etc.
                        ;
fb5b : a900             xParSetWrite	lda	#0	;select DDR
fb5d : 8d61e0           		sta	PIACTLA	;...for port A
fb60 : a9ff             		lda	#$ff	;set bits for output
fb62 : 8d60e0           		sta	PIADDRA
fb65 : a904             		lda	#4	;select data reg
fb67 : 8d61e0           		sta	PIACTLA
                        ;
                        ; Set direction flag to output, clear ACK bit
                        ;
fb6a : a901             		lda	#DIRECTION
fb6c : 8d62e0           		sta	PIAREGB
fb6f : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- ctmon65.asm ---------------------------------

                        ;*****************************************************
                        ; This sets up for reading from the Arduino.  Sets up
                        ; direction registers, clears the direction bit, etc.
                        ;
fb70 : a900             xParSetRead	lda	#0	;select DDR
fb72 : 8d61e0           		sta	PIACTLA	;...for port A
fb75 : a900             		lda	#$00	;set bits for input
fb77 : 8d60e0           		sta	PIADDRA
fb7a : a904             		lda	#4	;select data reg
fb7c : 8d61e0           		sta	PIACTLA
                        ;
                        ; Set direction flag to input, clear ACK bit
                        ;
fb7f : a900             		lda	#0
fb81 : 8d62e0           		sta	PIAREGB
fb84 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- ctmon65.asm ---------------------------------

                        ;*****************************************************
                        ; This writes a single byte to the Arduino.  On entry,
                        ; the byte to write is in A.  This assumes ParSetWrite
                        ; was already called.
                        ;
                        ; Destroys A, all other registers preserved.
                        ;
                        ; Write cycle:
                        ;
                        ;    1. Wait for other side to lower ACK.
                        ;    2. Put data onto the bus.
                        ;    3. Set DIRECTION and PSTROBE to indicate data
                        ;       is valid and ready to read.
                        ;    4. Wait for ACK line to go high, indicating the
                        ;       other side has read the data.
                        ;    5. Lower PSTROBE.
                        ;    6. Wait for ACK to go low, indicating end of
                        ;       transfer.
                        ;
fb85 : 48               xParWriteByte	pha		;save data
fb86 : ad62e0           Parwl22		lda	PIAREGB	;check status
fb89 : 2904             		and	#ACK
fb8b : d0f9             		bne	Parwl22	;wait for ACK to go low
                        ;
                        ; Now put the data onto the bus
                        ;
fb8d : 68               		pla
fb8e : 8d60e0           		sta	PIAREGA
                        ;
                        ; Raise the strobe so the Arduino knows there is
                        ; new data.
                        ;
fb91 : ad62e0           		lda	PIAREGB
fb94 : 0902             		ora	#PSTROBE
fb96 : 8d62e0           		sta	PIAREGB
                        ;
                        ; Wait for ACK to go high, indicating the Arduino has
                        ; pulled the data and is ready for more.
                        ;
fb99 : ad62e0           Parwl33		lda	PIAREGB
fb9c : 2904             		and	#ACK
fb9e : f0f9             		beq	Parwl33
                        ;
                        ; Now lower the strobe, then wait for the Arduino to
                        ; lower ACK.
                        ;
fba0 : ad62e0           		lda	PIAREGB
fba3 : 29fd             		and	#~PSTROBE
fba5 : 8d62e0           		sta	PIAREGB
fba8 : ad62e0           Parwl44		lda	PIAREGB
fbab : 2904             		and	#ACK
fbad : d0f9             		bne	Parwl44
fbaf : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- ctmon65.asm ---------------------------------

                        ;*****************************************************
                        ; This reads a byte from the Arduino and returns it in
                        ; A.  Assumes ParSetRead was called before.
                        ;
                        ; This does not have a time-out.
                        ;
                        ; Preserves all other registers.
                        ;
                        ; Read cycle:
                        ;
                        ;    1. Wait for other side to raise ACK, indicating
                        ;       data is ready.
                        ;    2. Read data.
                        ;    3. Raise PSTROBE indicating data was read.
                        ;    4. Wait for ACK to go low.
                        ;    5. Lower PSTROBE.
                        ;
fbb0 : ad62e0           xParReadByte	lda	PIAREGB
fbb3 : 2904             		and	#ACK	;is their strobe high?
fbb5 : f0f9             		beq	xParReadByte	;nope, no data
                        ;
                        ; Data is available, so grab and save it.
                        ;
fbb7 : ad60e0           		lda	PIAREGA
fbba : 48               		pha
                        ;
                        ; Now raise our strobe (their ACK), then wait for
                        ; them to lower their strobe.
                        ;
fbbb : ad62e0           		lda	PIAREGB
fbbe : 0902             		ora	#PSTROBE
fbc0 : 8d62e0           		sta	PIAREGB
fbc3 : ad62e0           Parrlp1		lda	PIAREGB
fbc6 : 2904             		and	#ACK
fbc8 : d0f9             		bne	Parrlp1	;still active
                        ;
                        ; Lower our ack, then were done.
                        ;
fbca : ad62e0           		lda	PIAREGB
fbcd : 29fd             		and	#~PSTROBE
fbcf : 8d62e0           		sta	PIAREGB
fbd2 : 68               		pla
fbd3 : 60               		rts
                        
                        		include "diskfunc.asm"
                        		list
                        ;=====================================================
                        ; This is a collection of functions for performing
                        ; higher level disk functions.  This hides the nasty
                        ; details of communications with the remote disk
                        ; system.
                        ;
                        ; August 20, 2014 - Bob Applegate
                        ;                   bob@corshamtech.com
                        ;
                        ; 06/14/2015 - Bob Applegate
                        ;		Now that there is an official standard
                        ;		for the protocol between the host (this
                        ;		code) and the DCP (Arduino code), this
                        ;		code has been updated to be compliant.
                        ;
                        ; 01/14/2016 - Bob Applegate
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- ctmon65.asm ---------------------------------

                        ;              Finally converted to 6502.
                        ;
                        ;		include	"parproto.inc"
                        ;
                        ; Number of drives emulated
                        ;
0004 =                  DRIVES		equ	4
                        ;
                        ;=====================================================
                        ; This is a sanity check to verify connectivity to the
                        ; Arduino code is working.  Returns C clear if all is
                        ; good, or C set if not.
                        ;
fbd4 : 205bfb           DiskPing	jsr	xParSetWrite
fbd7 : a905             		lda	#PC_PING	;command
fbd9 : 2085fb           		jsr	xParWriteByte	;send to Arduino
fbdc : 2070fb           		jsr	xParSetRead
fbdf : 20b0fb           		jsr	xParReadByte	;read their reply
fbe2 : 205bfb           DiskRetGood	jsr	xParSetWrite
fbe5 : 18               		clc			;assume it's good
fbe6 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- ctmon65.asm ---------------------------------

                        ;=====================================================
                        ; This starts a directory read of the raw drive, not
                        ; the mounted drive.  No input parameters.  This simpl
                        ; sets up for reading the entries, then the user must
                        ; read each entry.
                        ;
                        ; Returns with C clear on success.  If error, C is set
                        ; and A contains the error code.
                        ;
fbe7 : 205bfb           DiskDir		jsr	xParSetWrite
fbea : a910             		lda	#PC_GET_DIR	;send command
fbec : 2085fb           		jsr	xParWriteByte
fbef : 18               		clc		;assume it works
fbf0 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- ctmon65.asm ---------------------------------

                        ;=====================================================
                        ; Read the next directory entry.  On input, X (MSB)
                        ; and Y (LSB) point to a 13 byte area to receive the
                        ; drive data.
                        ;
                        ; Returns C set if end of directory (ie, attempt to
                        ; read and there are none left).  Else, C is clear
                        ; and X/Y point to the null at end of filename.
                        ;
fbf1 : 86f1             DiskDirNext	stx	sptr+1
fbf3 : 84f0             		sty	sptr
fbf5 : 2070fb           		jsr	xParSetRead	;read results
fbf8 : 20b0fb           		jsr	xParReadByte	;get response code
fbfb : c983             		cmp	#PR_NAK		;error?
fbfd : f01e             		beq	DDNErr
fbff : c991             		cmp	#PR_DIR_END	;end?
fc01 : f01a             		beq	DDNErr
                        ;
                        ; This contains a directory entry.
                        ;
fc03 : a000             		ldy	#0
fc05 : 20b0fb           DDNloop		jsr	xParReadByte
fc08 : 91f0             		sta	(sptr),y
fc0a : c900             		cmp	#0	;end?
fc0c : f006             		beq	DDNEnd
fc0e : 2033f9           		jsr	INCPT
fc11 : 4c05fc           		jmp	DDNloop
fc14 : 205bfb           DDNEnd		jsr	xParSetWrite
fc17 : a6f1             		ldx	sptr+1
fc19 : a4f0             		ldy	sptr
fc1b : 18               		clc		;not end of files
fc1c : 60               		rts
                        ;
                        ; Error.  Set C and return.  This is not really
                        ; proper, since this implies a simple end of the
                        ; directory rather than an error.
                        ;
fc1d : 205bfb           DDNErr		jsr	xParSetWrite
fc20 : 38               		sec
fc21 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- ctmon65.asm ---------------------------------

                        ;=====================================================
                        ; This opens a file on the SD for reading.  On entry,
                        ; X (MSB) and Y (LSB) point to a null-terminated
                        ; filename to open.  On return, C is clear if the file
                        ; is open, or C set if an error (usually means the
                        ; file does not exist.
                        ;
                        ; Assumes write mode has been set.  Returns with it se
                        ;
fc22 : a916             DiskOpenRead	lda	#PC_READ_FILE
fc24 : 84f2             DiskOpen	sty	INL	;save ptr to filename
fc26 : 86f3             		stx	INH
fc28 : 48               		pha
fc29 : 205bfb           		jsr	xParSetWrite
fc2c : 68               		pla
fc2d : 2085fb           		jsr	xParWriteByte
fc30 : a0ff             		ldy	#-1
fc32 : c8               DiskOpenLoop	iny
fc33 : b1f2             		lda	(INL),y
fc35 : 2085fb           		jsr	xParWriteByte
fc38 : b1f2             		lda	(INL),y
fc3a : d0f6             		bne	DiskOpenLoop
fc3c : 2070fb           		jsr	xParSetRead
fc3f : 20b0fb           		jsr	xParReadByte	;get response
fc42 : c982             		cmp	#PR_ACK
fc44 : d005             		bne	DiskOpenErr
fc46 : 205bfb           		jsr	xParSetWrite	;back to write mode
fc49 : 18               		clc
fc4a : 60               		rts
                        ;
                        ; Got an error.
                        ;
fc4b : 20b0fb           DiskOpenErr	jsr	xParReadByte	;get error code
fc4e : 205bfb           		jsr	xParSetWrite	;back to write mode
fc51 : 38               		sec
fc52 : 60               		rts
                        ;=====================================================
                        ; This opens a file on the SD for writing.  On entry,
                        ; X (MSB) and Y (LSB) point to a null-terminated
                        ; filename to open.  On return, C is clear if the file
                        ; is open, or C set if an error.
                        ;
                        ; Assumes write mode has been set.  Returns with it se
                        ;
fc53 : a91b             DiskOpenWrite	lda	#PC_WRITE_FILE
fc55 : 4c24fc           		jmp	DiskOpen	;jump into common code
                        ;
                        ;=====================================================
                        ; On entry, A contains the number of bytes to read
                        ; from the file, X (MSB) and Y (LSB) point to the
                        ; buffer where to put the data.  On return, C will
                        ; be set if EOF was reached (and no data read), or
                        ; C will be clear and A contains the number of bytes
                        ; actually read into the buffer.
                        ;
                        ; Modifies A, X and Y.  Also modifies INL and INH
                        ; (00F8 and 00F9).
                        ;
fc58 : 48               DiskRead	pha
fc59 : 84f2             		sty	INL	;save ptr to buffer
fc5b : 86f3             		stx	INH
fc5d : a917             		lda	#PC_READ_BYTES
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- ctmon65.asm ---------------------------------

fc5f : 2085fb           		jsr	xParWriteByte	;command
fc62 : 68               		pla		;number of bytes to get
fc63 : 2085fb           		jsr	xParWriteByte
fc66 : 2070fb           		jsr	xParSetRead	;get ready for response
fc69 : 20b0fb           		jsr	xParReadByte	;assume PR_FILE_DATA
fc6c : 20b0fb           		jsr	xParReadByte	;length
fc6f : 48               		pha
fc70 : aa               		tax			;count
fc71 : f011             		beq	DiskReadEof	;zero = EOF
fc73 : a000             		ldy	#0	;offset
fc75 : 20b0fb           DiskReadLoop	jsr	xParReadByte
fc78 : 91f2             		sta	(INL),y
fc7a : c8               		iny		;next offset
fc7b : ca               		dex
fc7c : d0f7             		bne	DiskReadLoop
fc7e : 205bfb           		jsr	xParSetWrite
fc81 : 68               		pla		;retrieve byte count
fc82 : 18               DiskOk		clc	
fc83 : 60               		rts
fc84 : 205bfb           DiskReadEof	jsr	xParSetWrite
fc87 : 68               		pla
fc88 : 38               		sec
fc89 : 60               		rts
                        ;
                        ;=====================================================
                        ; On entry, A contains the number of bytes to write
                        ; to the file, X (MSB) and Y (LSB) point to the
                        ; buffer where to get the data.  On return, C will
                        ; be set if an error was detected, or C will be clear
                        ; if no error.  Note that if A contains 0 on entry,
                        ; no bytes are written.
                        ;
                        ; Modifies A, X and Y.  Also modifies INL and INH
                        ; (00F8 and 00F9).
                        ;
fc8a : c900             DiskWrite	cmp	#0
fc8c : f0f4             		beq	DiskOk
fc8e : 84f2             		sty	INL	;save ptr to filename
fc90 : 86f3             		stx	INH
fc92 : 48               		pha
fc93 : a91c             		lda	#PC_WRITE_BYTES
fc95 : 2085fb           		jsr	xParWriteByte	;command
fc98 : 68               		pla		;number of bytes to write
fc99 : 48               		pha		;save again
fc9a : 2085fb           		jsr	xParWriteByte
fc9d : 68               		pla
fc9e : aa               		tax			;count
fc9f : a000             		ldy	#0	;offset
fca1 : b1f2             DiskWriteLoop	lda	(INL),y	;get next byte
fca3 : 2085fb           		jsr	xParWriteByte
fca6 : c8               		iny		;next offset
fca7 : ca               		dex
fca8 : d0f7             		bne	DiskWriteLoop
fcaa : 2070fb           		jsr	xParSetRead ;read the status
fcad : 20b0fb           		jsr	xParReadByte
fcb0 : c982             		cmp	#PR_ACK
fcb2 : f008             		beq	DiskOk1	;all good
fcb4 : 20b0fb           		jsr	xParReadByte	;read error code
fcb7 : 205bfb           		jsr	xParSetWrite 
fcba : 38               		sec	
fcbb : 60               		rts
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- ctmon65.asm ---------------------------------

fcbc : 205bfb           DiskOk1		jsr	xParSetWrite
fcbf : 18               		clc
fcc0 : 60               		rts
                        ;
                        ;=====================================================
                        ; Call this to close any open file.  No parameters
                        ; and no return status.
                        ;
fcc1 : a915             DiskClose	lda	#PC_DONE
fcc3 : 4c85fb           		jmp	xParWriteByte
                        
                        
                        
                        	endif
                        ;
                        ;*****************************************************
                        ; Handlers for the interrupts.  Basiclly just jump 
                        ; through the vectors and hope they are set up properl
                        ;
fcc6 : 6c02df           HandleNMI	jmp	(NMIvec)
fcc9 : 6c00df           HandleIRQ	jmp	(IRQvec)
                        ;
                        ;*****************************************************
                        ; Default handler.  Save the state of the machine for
                        ; debugging.  This is taken from the KIM monitor SAVE
                        ; routine.
                        ;
fccc :                  DefaultNMI
fccc : 8d8edf           DefaultIRQ	sta	SaveA
fccf : 68               		pla
fcd0 : 8d93df           		sta	SaveC
fcd3 : 68               		pla
fcd4 : 8d91df           		sta	SavePC
fcd7 : 68               		pla
fcd8 : 8d92df           		sta	SavePC+1
fcdb : 8c90df           		sty	SaveY
fcde : 8e8fdf           		stx	SaveX
fce1 : ba               		tsx
fce2 : 8e94df           		stx	SaveSP
fce5 : 209bf6           		jsr	DumpRegisters
fce8 : 2007fb           		jsr	crlf
fceb : 4cb4f0           		jmp	WARM
                        ;
                        ;*****************************************************
                        ; 6502 vectors
                        ;
fffa =                  		org	$fffa
fffa : c6fc             		dw	HandleNMI
fffc : 45f0             		dw	RESET
fffe : c9fc             		dw	HandleIRQ
                        
                        
No errors in pass 2.
Wrote binary from address $e000 through $ffff.
Total size 8192 bytes.
